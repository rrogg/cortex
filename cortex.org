#+TITLE: CORTEX - AN EMACS CONFIGURATION
#+PROPERTY: header-args :result silent :tangle "~/.emacs.d/init.el" :eval no-export :comments org

* Track Loading Time of Cortex

Starting Emacs has to be as quick as possible. In order to evaluate the time it
takes to load Cortex, someone has to blow the whistle and start the stopwatch.

#+BEGIN_SRC emacs-lisp
(defvar my-cortex-start-time (current-time) "Time when Cortex was started")
#+END_SRC

* Wrap Lines at a Reasonable Width

Long lines of text have to be wrapped at a width of 80 characters. In order to
leave long code lines untouched, automatic line wrap is only active in
=text-mode= and modes which inherit from =text-mode=, like e.g. =org-mode=.

#+BEGIN_SRC emacs-lisp
(setq-default fill-column 80)
(add-hook 'text-mode-hook 'auto-fill-mode)
#+END_SRC

* Stop the Bell

Acoustic feedback is not wanted for this system. Therefore stop ringing the bell!

#+BEGIN_SRC emacs-lisp
(setq ring-bell-function #'ignore)
#+END_SRC

* Hide Welcome Screen and Empty =*scratch*=

Emacs shows a splash screen at startup from which one can easily get to the
tutorial. While helpful in the beginning, this screen gets abdicable with
time. Therefore it's disabled.
Emacs also automatically loads a buffer called =*scratch*=, which serves as a
place to try out emacs lisp code or to type out some ideas. This is very helpful
as one doesn't have to think about creating a new file for every unrelated
thought. The welcome message isn't needed, so it gets disabled.

#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t
      initial-scratch-message nil)
#+END_SRC

* Force a Sane Coding System

The only way to go in regards of a sane coding system for text files is utf-8.
It has to be the the default when ever possible. This provides maximal
portability and readability across operation systems and applications.
Also the Unix way of adding a new line into a text file has to be the
default. DOS uses carriage return and line feed ("\r\n") as a line ending, where
Unix uses just line feed ("\n").

#+BEGIN_SRC emacs-lisp
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8-unix)
(set-charset-priority 'unicode)
(setq default-process-coding-system '(utf-8-unix . utf-8-unix)
      locale-coding-system 'utf-8)
#+END_SRC

* Answer Questions Quicker

Emacs sometimes requires answering a yes-or-no question in order to make the
user aware of probably dangerous changes or decisions.
Simply pressing =y= for a positive or =n= for a negative response is way more
convenient compared to spelling out the whole words =yes= or =no=.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

* Highlight Current Line in Buffer

To make orientation within the buffer easy, the current line on which point is
gets highlighted.

#+BEGIN_SRC emacs-lisp
(global-hl-line-mode t)
#+END_SRC

* Use Ibuffer to Edit the Buffer List

By default =C-x C-b= calls the Buffer List. Ibuffer is an alternative with more
functionality when it comes to manipulate the buffer list and switching
buffers.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC

* Provide and Manage Packages
** =package.el=

Most extensions to Emacs can be loaded from archives, which are accessible via
Emacs' very own package manager =package.el=. To use this feature, =package.el=
needs to know, which archives it should use.
Out of the box, Emacs includes the =GNU ELPA= archive. It contains packages
conform with the terms of the Free Software Foundation.
For using the Org mode contribution files (some extra packages not included in
the Org mode version shipped with Emacs) and installing them via =package.el=,
the =Org ELPA= archive is added.
=MELPA= is an archive containing a lot of packages from the Open Source
community, which is the source for a lot of packages used in Cortex.
To make shure all packages mentioned in Cortex are loaded at Emacs startup, the
init file has to call the function =package-initialize=. This is necessary,
because some code blocks within Cortex depend on a packages installed by
=package.el=.

#+BEGIN_SRC emacs-lisp
(package-initialize)
(add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/") t)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
#+END_SRC

The command =M-x list-packages= brings up the package menu buffer, which lists
all packages available from the archives defined above. The command retrieves
the list of packages from the archive servers, if it has a connection to the
internet. Else it uses the most recently retrieved list.

Here are some of the frequently used commands in the package menu buffer:

| Key     | Command                      | Description                                                                                                                                                |
|---------+------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------|
| h       | (package-menu-quick-help)    | Summary of commands in the package menu buffer                                                                                                             |
| r       | (package-menu-refresh)       | Refresh package list                                                                                                                                       |
| i       | (package-menu-mark-install)  | Mark the package on the current line for installation (adds an ‘I’ character to the start of the line)                                                     |
| d       | (package-menu-mark-delete)   | Mark the package on the current line for deletion (adds a ‘D’ character to the start of the line                                                           |
| u <RET> |                              | Remove any installation or deletion mark previously added to the current line                                                                              |
| U       | (package-menu-mark-upgrades) | Mark all package with a newer available version for upgrading.  This places an ‘I’ on the new available versions, and a ‘D’ on the old installed versions. |
| x       | (package-menu-execute)       | Download and install all packages marked with ‘I’, and their dependencies; also, delete all packages marked with ‘D’                                       |

The command =(package-install PKG)= can be used to install package "PKG"
manually from a code block within Cortex.

** =use-package=

Most Emacs configurations out there tend to be quite extensive. I expect nothing
else for Cortex. Over time, it will grow and become cluttered. Loading time will
most likely go up linked to the size of packages used.
Having more control over when things get loaded or when certain code is executed
is very welcome.
The macro =use-package= provides this control. It isolates packages
configuration in an Emacs config so that code belonging to a certain package
only is executed when the package is loaded. When a package is loaded it is also
configurable. This has the potential to squeeze some performance out of Cortex
and to make Cortex clean, tidy and organized.
=use-package= obviously can't be installed by using its own macro. It needs to
be installed by the commands from =package.el=. Following the idea of using
=use-package= for every package within Cortex, this should be the only time a
package is installed without the =use-package= macro.

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
#+END_SRC

=use-package= provides several keywords to load and configure a package.
See a basic example below.

#+BEGIN_EXAMPLE emacs-lisp
(use-package foo
  :ensure t
  :init
  (setq foo-variable t)
  :config
  (foo-mode 1))
#+END_EXAMPLE

The macro starts with =use-package foo=, which will load the package =foo=, but
only, if it's already available on the system (else, a warning gets logged).

=:ensure t= makes sure, that the package is installed and will download it from
the package archives, if it's not present on the system. This is how packages
are fetched and installed in Cortex.

The =:init= keyword executes code before a package is loaded. It accepts one
or more forms, up to the next keyword. 

Similarly, =:config= can be used to execute code after a package is loaded.

* Using git Within Emacs

=magit= is a superb interface to =git=.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t)
#+END_SRC

** How to Write a Good Commit Message

A good commit message follows [[https://chris.beams.io/posts/git-commit/][7 rules]]:

1. Separate subject from body with a blank line
2. Limit the subject line to 50 characters
3. Capitalize the subject line
4. Do not end the subject line with a period
5. Use the imperative mood in the subject line
6. Wrap the body at 72 characters
7. Use the body to explain what and why vs. how

For example:

#+BEGIN_EXAMPLE
Summarize changes in around 50 characters or less

More detailed explanatory text, if necessary. Wrap it to about 72
characters or so. In some contexts, the first line is treated as the
subject of the commit and the rest of the text as the body. The
blank line separating the summary from the body is critical (unless
you omit the body entirely); various tools like `log`, `shortlog`
and `rebase` can get confused if you run the two together.

Explain the problem that this commit is solving. Focus on why you
are making this change as opposed to how (the code explains that).
Are there side effects or other unintuitive consequences of this
change? Here's the place to explain them.

Further paragraphs come after blank lines.

 - Bullet points are okay, too

 - Typically a hyphen or asterisk is used for the bullet, preceded
   by a single space, with blank lines in between, but conventions
   vary here

If you use an issue tracker, put references to them at the bottom,
like this:

Resolves: #123
See also: #456, #789
#+END_EXAMPLE

All stylistic rules can be taken care of by =magit=.
It will color characters on the summary line exceeding length of 50 red and does
the same for the second line, which should be blank.
The body of the message is wrapped at length 72.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :config
    (setq git-commit-summary-max-length 50
          git-commit-fill-column 72))
#+END_SRC

* Maximize Frame Window

The Emacs frame is maximized at all times to make use of every pixel on the
screen.

#+BEGIN_SRC emacs-lisp
(toggle-frame-maximized)
#+END_SRC

* Final Spurt

This is the end of Cortex. Let's see how much time it took to load all of the
shenanigans. Write the result to the =Messages= buffer.

#+BEGIN_SRC emacs-lisp
(message "→★ Finished loading Cortex in %.2fs" (float-time (time-subtract (current-time) my-cortex-start-time)))
#+END_SRC
