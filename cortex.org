#+TITLE: CORTEX - AN EMACS CONFIGURATION
#+PROPERTY: header-args :result silent :tangle "~/.emacs.d/init.el" :eval no-export :comments org

* Track Loading Time of Cortex

Starting Emacs has to be as quick as possible. In order to evaluate the time it
takes to load Cortex, someone has to blow the whistle and start the stopwatch.

#+BEGIN_SRC emacs-lisp
(defvar rrogg/cortex-start-time (current-time) "Time when Cortex was started")
(message "\n★→ Cortex")
#+END_SRC

The start time is also used in logs. The format of the time string is different
from =rrogg/cortex-start-time=.

#+BEGIN_SRC emacs-lisp
(setq rrogg/cortex-start-time-iso (format-time-string "%Y-%m-%dT%T"))
#+END_SRC

* Server Start

Emacs offers a server mode, which allows to open additional from outside of
Emacs in the same session that is already running. No need to open a file in
another Emcas and reload the complete config again for it.

#+BEGIN_SRC emacs-lisp
(server-start)
#+END_SRC

* Support for Non-Linux Systems

** Windows

*** Installation
Emacs is installed from chocolatey via =cmd.exe=:

#+BEGIN_EXAMPLE
choco install emacs
#+END_EXAMPLE

The environment variable =HOME= does not exist by default, so it needs to be
created manually:

#+BEGIN_EXAMPLE
This PC (right-click)
-> Properties
-> Computer name, domain, and workgroup settings
-> Change settings
-> Advanced
-> Environment Variables...
-> New
HOME C:\home\rrogg
#+END_EXAMPLE

On first start of Emacs, the =~/.emacs.d/= directory gets created automatically.

*** Cloning Cortex Repository

In order to clone the Cortex repository, install =git= from =chocolatey= via
=cmd.exe=:

#+BEGIN_EXAMPLE
choco install git
#+END_EXAMPLE

=git= should be automatically found by Emacs, no need to add it to the path.

Clone Cortex via =git bash=:

#+BEGIN_EXAMPLE
cd ~/src
git clone https://github.com/rrogg/cortex.git
#+END_EXAMPLE

*** General Issues

**** =~/.emacs.d/server/= unsafe location

Emacs complaints about =~/.emacs.d/server/= not beeing a safe loacation (magit,
server-start).
This is resolved by changing the access rights to that folder via =cmd.exe=:

#+BEGIN_EXAMPLE
cd %HOME%\.emacs.d
takeown /f server
#+END_EXAMPLE

**** Attach Files to Already Open Emacs Session

When Emacs is started as a daemon (=(server-start)=), all additionaly opened
files should be openend within the current session and not in a seperate
instance of Emacs. That instance would load Cortex again, which takes time. The
buffer list is also not shared between those instances.

Emacs on Windows comes with several execuatables, of which I use two:

- =runemacs.exe=
- =emacsclientw.exe=

Should Emacs not be started, e.g. after a reboot, I use =runemacs.exe= to do so.
Loading Cortex, Emacs will create a daemon in the background, to which other
files can be attached when they are opened.
Opening files is either done directly from within Emacs or by opening them from
a folder.
In order to always attach those externaly opened files to the running session, I
use =emacsclientw.exe= with some parameters. It needs a file name to open in order to
start Emacs, so I can't use it to start Emacs in a way that it always does what
I want.
The =Target= value of the shortcut is the following:

#+BEGIN_EXAMPLE
C:\ProgramData\chocolatey\bin\emacsclientw.exe -n -a ""
#+END_EXAMPLE

If there is a Emacs server running, it will open the file in the current
session. If no server has been started yet, it will do so (=-a ""=).

Now this shortcut has to be set as default programm to open the specific file
extension with. This has to be done once per file extension.
I created the shortcut in =C:\ProgramData\Microsoft\Windows\Start Menu\Programs=.
It could also be set via Windows Registry, but I failed to add more file
extensions to the =.reg= file. This file just needs to be executed and it will
set the default programm.

#+BEGIN_EXAMPLE
Windows Registry Editor Version 5.00
[HKEY_CURRENT_USER\Software\Classes\texfile]
[HKEY_CURRENT_USER\Software\Classes\texfile\Shell]
[HKEY_CURRENT_USER\Software\Classes\texfile\Shell\Open]
[HKEY_CURRENT_USER\Software\Classes\texfile\Shell\Open\Command]
@="C:\\ProgramData\\chocolatey\\bin\\emacsclientw.exe -n -a \"C:\\ProgramData\\chocolatey\\bin\\runemacs.exe\" \"%1\" %*"
[HKEY_CURRENT_USER\Software\Classes\.tex]
@="texfile"
[HKEY_CURRENT_USER\Software\Classes\.bib]
@="texfile"
[HKEY_CURRENT_USER\Software\Classes\.lco]
@="texfile"
[HKEY_CURRENT_USER\Software\Classes\.sty]
@="texfile"
[HKEY_CURRENT_USER\Software\Classes\.cls]
@="texfile"
[HKEY_CURRENT_USER\Software\Classes\txtfile]
[HKEY_CURRENT_USER\Software\Classes\txtfile\Shell]
[HKEY_CURRENT_USER\Software\Classes\txtfile\Shell\Open]
[HKEY_CURRENT_USER\Software\Classes\txtfile\Shell\Open\Command]
@="C:\\ProgramData\\chocolatey\\bin\\emacsclientw.exe -n -a \"C:\\ProgramData\\chocolatey\\bin\\runemacs.exe\" \"%1\" %*"
[HKEY_CURRENT_USER\Software\Classes\.txt]
@="txtfile"
[HKEY_CURRENT_USER\Software\Classes\.org]
@="txtfile"
[HKEY_CURRENT_USER\Software\Classes\scriptfile]
[HKEY_CURRENT_USER\Software\Classes\scriptfile\Shell]
[HKEY_CURRENT_USER\Software\Classes\scriptfile\Shell\Open]
[HKEY_CURRENT_USER\Software\Classes\scriptfile\Shell\Open\Command]
@="C:\\ProgramData\\chocolatey\\bin\\emacsclientw.exe -n -a \"C:\\ProgramData\\chocolatey\\bin\\runemacs.exe\" \"%1\" %*"
[HKEY_CURRENT_USER\Software\Classes\.sh]
@="scriptfile"
[HKEY_CURRENT_USER\Software\Classes\cfile]
[HKEY_CURRENT_USER\Software\Classes\cfile\Shell]
[HKEY_CURRENT_USER\Software\Classes\cfile\Shell\Open]
[HKEY_CURRENT_USER\Software\Classes\cfile\Shell\Open\Command]
@="C:\\ProgramData\\chocolatey\\bin\\emacsclientw.exe -n -a \"C:\\ProgramData\\chocolatey\\bin\\runemacs.exe\" \"%1\" %*"
[HKEY_CURRENT_USER\Software\Classes\.c]
@="cfile"
[HKEY_CURRENT_USER\Software\Classes\.h]
@="cfile"
#+END_EXAMPLE

* Disable GUI components

Display no GUI components other than the =modline=.

#+BEGIN_SRC emacs-lisp
(use-package emacs
  :init
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1))
#+END_SRC

* Wrap Lines at a Reasonable Width

Long lines of text have to be wrapped at a width of 80 characters. In order to
leave long code lines untouched, automatic line wrap is only active in
=text-mode= and modes which inherit from =text-mode=, like e.g. =org-mode=.

#+BEGIN_SRC emacs-lisp
(setq-default fill-column 80)
(add-hook 'text-mode-hook 'auto-fill-mode)
#+END_SRC

* Stop the Bell

Acoustic feedback is not wanted for this system. Therefore stop ringing the bell!

#+BEGIN_SRC emacs-lisp
(setq ring-bell-function #'ignore)
#+END_SRC

* Hide Welcome Screen and Empty =*scratch*=

Emacs shows a splash screen at startup from which one can easily get to the
tutorial. While helpful in the beginning, this screen gets abdicable with
time. Therefore it's disabled.
Emacs also automatically loads a buffer called =*scratch*=, which serves as a
place to try out emacs lisp code or to type out some ideas. This is very helpful
as one doesn't have to think about creating a new file for every unrelated
thought. The welcome message isn't needed, so it gets disabled.

#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t)
(setq initial-scratch-message nil)
#+END_SRC

* Force a Sane Coding System

The only way to go in regards of a sane coding system for text files is utf-8.
It has to be the the default when ever possible. This provides maximal
portability and readability across operation systems and applications.
Also the Unix way of adding a new line into a text file has to be the
default. DOS uses carriage return and line feed ("\r\n") as a line ending, where
Unix uses just line feed ("\n").

#+BEGIN_SRC emacs-lisp
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8-unix)
(setq-default buffer-file-coding-system 'utf-8-unix)
(set-charset-priority 'unicode)
(setq default-process-coding-system '(utf-8-unix . utf-8-unix))
(setq locale-coding-system 'utf-8)
#+END_SRC

* Answer Questions Quicker

Emacs sometimes requires answering a yes-or-no question in order to make the
user aware of probably dangerous changes or decisions.
Simply pressing =y= for a positive or =n= for a negative response is way more
convenient compared to spelling out the whole words =yes= or =no=.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

* Highlight Current Line in Buffer

To make orientation within the buffer easy, the current line on which point is
gets highlighted.

#+BEGIN_SRC emacs-lisp
(global-hl-line-mode t)
#+END_SRC

* Use Ibuffer to Edit the Buffer List

By default =C-x C-b= calls the Buffer List. Ibuffer is an alternative with more
functionality when it comes to manipulate the buffer list and switching
buffers.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC

* Provide and Manage Packages
** =package.el=

Most extensions to Emacs can be loaded from archives, which are accessible via
Emacs' very own package manager =package.el=. To use this feature, =package.el=
needs to know, which archives it should use.
Out of the box, Emacs includes the =GNU ELPA= archive. It contains packages
conform with the terms of the Free Software Foundation.
For using the Org mode contribution files (some extra packages not included in
the Org mode version shipped with Emacs) and installing them via =package.el=,
the =Org ELPA= archive is added.
=MELPA= is an archive containing a lot of packages from the Open Source
community, which is the source for a lot of packages used in Cortex.
To make shure all packages mentioned in Cortex are loaded at Emacs startup, the
init file has to call the function =package-initialize=. This is necessary,
because some code blocks within Cortex depend on a packages installed by
=package.el=.

#+BEGIN_SRC emacs-lisp
(package-initialize)
(add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/") t)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
#+END_SRC

The command =M-x list-packages= brings up the package menu buffer, which lists
all packages available from the archives defined above. The command retrieves
the list of packages from the archive servers, if it has a connection to the
internet. Else it uses the most recently retrieved list.

Here are some of the frequently used commands in the package menu buffer:

| Key     | Command                      | Description                                                                                                                                                |
|---------+------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------|
| h       | (package-menu-quick-help)    | Summary of commands in the package menu buffer                                                                                                             |
| r       | (package-menu-refresh)       | Refresh package list                                                                                                                                       |
| i       | (package-menu-mark-install)  | Mark the package on the current line for installation (adds an ‘I’ character to the start of the line)                                                     |
| d       | (package-menu-mark-delete)   | Mark the package on the current line for deletion (adds a ‘D’ character to the start of the line                                                           |
| u <RET> |                              | Remove any installation or deletion mark previously added to the current line                                                                              |
| U       | (package-menu-mark-upgrades) | Mark all package with a newer available version for upgrading.  This places an ‘I’ on the new available versions, and a ‘D’ on the old installed versions. |
| x       | (package-menu-execute)       | Download and install all packages marked with ‘I’, and their dependencies; also, delete all packages marked with ‘D’                                       |

The command =(package-install PKG)= can be used to install package "PKG"
manually from a code block within Cortex.

** =use-package=

Most Emacs configurations out there tend to be quite extensive. I expect nothing
else for Cortex. Over time, it will grow and become cluttered. Loading time will
most likely go up linked to the size of packages used.
Having more control over when things get loaded or when certain code is executed
is very welcome.
The macro =use-package= provides this control. It isolates packages
configuration in an Emacs config so that code belonging to a certain package
only is executed when the package is loaded. When a package is loaded it is also
configurable. This has the potential to squeeze some performance out of Cortex
and to make Cortex clean, tidy and organized.
=use-package= obviously can't be installed by using its own macro. It needs to
be installed by the commands from =package.el=. Following the idea of using
=use-package= for every package within Cortex, this should be the only time a
package is installed without the =use-package= macro.

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
#+END_SRC

Some defaults are changed before =use-package= is loaded.
In order to make better use of the help commands, hooks are written using their
full name, when using the =:hook= option of =use-package= (after-init ==>
after-init-hook).

#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (setq use-package-hook-name-suffix nil))
(eval-when-compile
  (require 'use-package))
#+END_SRC

=use-package= provides several keywords to load and configure a package.
See a basic example below.

#+BEGIN_EXAMPLE emacs-lisp
(use-package foo
  :ensure t
  :init
  (setq foo-variable t)
  :config
  (foo-mode 1))
#+END_EXAMPLE

The macro starts with =use-package foo=, which will load the package =foo=, but
only, if it's already available on the system (else, a warning gets logged).

=:ensure t= makes sure, that the package is installed and will download it from
the package archives, if it's not present on the system. This is how packages
are fetched and installed in Cortex.

The =:init= keyword executes code before a package is loaded. It accepts one
or more forms, up to the next keyword. 

Similarly, =:config= can be used to execute code after a package is loaded.

* Themes

| [2020-11-03] | Initial setup |

The look of Emacs is defined in a theme. Custom themes usually alter e.g. the
colours used to highlight headings or code.
Readability and accessibility has highest priority. This may be to the expense
of having a "stylish" looking Emacs, but that's OK.

I found out about the =Modus= themes created by [[https://protesilaos.com][Protesilaos Stavrou]] while
watching one of his videos about Emacs. Those themes are conform with the
highest accessibility standard for colour contrast between background and
foreground values (WCAG AAA).

The themes will be shipped with Emacs starting version =28.1=. They are also
available from ELPA and Melpa archives. The version from Melpa is a
representation of the latest commit to the master branch of the themes repo and
should be the latest version available.

=Modus Operandi= is the light variant.

#+BEGIN_SRC emacs-lisp
(use-package modus-operandi-theme
  :ensure t
  :pin melpa)
#+END_SRC

=Modus Vivendi= is the dark variant.

#+BEGIN_SRC emacs-lisp
(use-package modus-vivendi-theme
  :ensure t
  :pin melpa)
#+END_SRC

The themes come with a lot of options for customization. If those are used, they
need to be set prior to the loading of the theme. It is very likely that
customizations should have effect on both variants of the theme. Therefore a
wrapper function can be used for customization and loading of the two themes.

A helper macro is needed to make this work.
=rrogg/format-sexp= will replace the symbolic expressions within =sexp= with
objects defined in =objects= and evaluate the resulting code.

#+BEGIN_SRC emacs-lisp
(use-package emacs
  :config
  (defmacro rrogg/format-sexp (sexp &rest objects)
    `(eval (read (format ,(format "%S" sexp) ,@objects)))))
#+END_SRC

The =rrogg/modus-theme-after-load-hook= can be used to run additional code
specifically after a theme has been loaded.

With the help of =rrogg/format-sexp= each of the two theme variants get a separate
function (=rrogg/modus-operandi= and =rrogg/modus-vivendi=) from a single source of
code. All customizations can be done here.

#+BEGIN_SRC emacs-lisp
(use-package emacs
  :config
  (defvar rrogg/modus-theme-after-load-hook nil
    "Hook that runs after loading a Modus theme.")

  (dolist (themes '("operandi" "vivendi"))
    (rrogg/format-sexp
      (defun rrogg/modus-%1$s ()
        (setq modus-%1$s-theme-org-blocks nil)
        (setq modus-%1$s-theme-scale-headings nil)
        (load-theme 'modus-%1$s t)
        (run-hooks 'rrogg/modus-theme-after-load-hook))
      themes)))
#+END_SRC

The light theme is the default.
I like to toggle between the variants manually for now.
There are options to switch between the variants atomatically by referencing
sunset and sundown, which might be explored further in the future.

#+BEGIN_SRC emacs-lisp
(use-package emacs
  :config
  (defun rrogg/themes-toggle ()
    "Toggle between light theme (`rrogg/modus-operandi') and dark theme (`rrogg/modus-vivendi')."
    (interactive)
    (if (eq (car custom-enabled-themes) 'modus-operandi)
        (progn
          (disable-theme 'modus-operandi)
          (rrogg/modus-vivendi))
      (disable-theme 'modus-vivendi)
      (rrogg/modus-operandi)))
  :hook (after-init-hook . rrogg/modus-vivendi)
  :bind ("<f5>" . rrogg/themes-toggle))
#+END_SRC

* Fonts

Typefaces (e.g. Inter) and fonts (e.g. Inter Extra Light 12) can be defined by
=set-face-attribute=. There are three faces: =default=, =fixed-pitch=
(monospaced) and =variable-pitch= (proportionally spaced). =fixed-pitch= is used
in programming modes. Sometimes reading prose or non-code texts is easier when
displayed in a =variable-pitch=.

For now, I'll start with my font choices from earlier configurations. Those are
=Hack= as monospaced font and =Inter= as proportionally spaced font.

#+BEGIN_SRC emacs-lisp
(use-package emacs
  :config
  (set-face-attribute 'default nil :family "Hack" :height 120)
  (set-face-attribute 'fixed-pitch nil :family "Hack" :height 120)
  (set-face-attribute 'variable-pitch nil :family "Inter" :height 120))
#+END_SRC

** Linux

=Hack= and =Inter= can be installed via =pacman=.

#+BEGIN_EXAMPLE
sudo pacman -S ttf-hack inter-font
#+END_EXAMPLE

Fonts will be installed to:

- =~/.local/share/fonts=  #if installed per user, without =sudo=
- =/usr/share/fonts=

** Windows

=Hack= can be installed via chocolatey.

#+BEGIN_EXAMPLE
chocolatey install hackfont
#+END_EXAMPLE

=Inter= needs to be downloaded from the [[https://rsms.me/inter/][website]] and installed manually according
to the included install instructions.

* no-littering - Keep .emacs.d Clean

| [2020-10-20] | Initial setup |

#+BEGIN_SRC emacs-lisp
(use-package no-littering
  :ensure t)
(require 'no-littering)
#+END_SRC

* Logging

Because Cortex is likely used on multiple hosts, each of those requires
host-specific logging. This will make it easier to compare versions of Emacs and
its packages. The following code is heavily inspired by a [[https://github.com/novoid/dot-emacs/blob/master/config.org#host-specific-log-file-my-log-hostspecific][section in Karl Voit's
dot-emacs]].

A folder for all sorts of logs is defined in =rrogg/cortex-var-log-directory=. If
this folder is not existing, it gets created.
The log file is defined in =rrogg/cortex-var-log-hostname-file= and consists of the
hostname of the system.

#+BEGIN_SRC emacs-lisp
(setq rrogg/cortex-var-log-directory (concat no-littering-var-directory "log/"))
(when (not (file-exists-p rrogg/cortex-var-log-directory))
  (make-directory rrogg/cortex-var-log-directory))
(setq rrogg/cortex-var-log-hostname-file (concat rrogg/cortex-var-log-directory "host-" system-name ".txt"))
#+END_SRC

The content of the host-specific log is similar to the following:

#+BEGIN_EXAMPLE
Started on 2020-10-20T22:09:44
emacs-version 27.1
org-version 9.1.6
magit-version 2.10.3
#+END_EXAMPLE

At startup of Emacs the host-specific log file is overwritten wit the current time.

#+BEGIN_SRC emacs-lisp
(write-region (concat "Started on " rrogg/cortex-start-time-iso "\n") nil rrogg/cortex-var-log-hostname-file)
#+END_SRC

Using the function =rrogg/cortex-log-hostspecific=, will append a string,
e.g. emacs-version, and a command, e.g. =emacs-version=, to the log file.

#+BEGIN_SRC emacs-lisp
(defun rrogg/cortex-log-hostspecific (string command)
  "append a string and the result of a command to the rrogg/cortex-var-log-hostname-file file"
  (interactive)
  (write-region (concat string " " command "\n") nil rrogg/cortex-var-log-hostname-file t)
)
#+END_SRC

This is the first use of the function above. Write the Emacs version to the log
file.

#+BEGIN_SRC emacs-lisp
(rrogg/cortex-log-hostspecific "emacs-version" emacs-version)
#+END_SRC

* Check for Binaries

Some functionality in Cortex depends on external binaries.
Receiving feedback if those are present on the system is valuable for
debugging.
The function =rrogg/binary-found= returns the path for a given binary.

#+BEGIN_SRC emacs-lisp
(defun rrogg/binary-found(binaryname)
  "Returns the path where a binary executable can be found."
  (locate-file binaryname exec-path exec-suffixes 1))
#+END_SRC

This can be used to generate a report like below:

#+BEGIN_EXAMPLE
git binary: /usr/bin/git
aspell binary: /usr/bin/aspell
gnuplot binary:
#+END_EXAMPLE

The function =rrogg/eval-if-binary-or-warn= checks for a given binary and writes
the binary name into the list =rrogg/binary-not-found-list=.
The list is displayed in the =*Messages*= buffer after Cortex has been loaded.

#+BEGIN_SRC emacs-lisp
(defvar rrogg/binary-not-found-list nil
  "Holds a list of binaries which could not be found via rrogg/eval-if-binary-or-warn()")
(defun rrogg/eval-if-binary-or-warn (binaryname &optional warningtext)
  "Checks if a binary can be found in the path via rrogg/binary-found().

  If not found, a warning message is printed, which can be defined as an optional parameter as well.
  Additionally, the not found binaries are collected in the variable rrogg/binary-not-found-list."
  (or warningtext (setq warningtext (concat "»»» I could not locate the PATH-binary for: " binaryname)))
  (let* ((binarypath (rrogg/binary-found binaryname)))
    (if binarypath
      ;; binary was found in exec-path
      (concat binarypath)
    (progn
      ;; binary NOT found in exec-path:
      (message warningtext)
      (if rrogg/binary-not-found-list
        (add-to-list 'rrogg/binary-not-found-list binaryname)
        (setq rrogg/binary-not-found-list (list binaryname)))))))
#+END_SRC

=rrogg/eval-if-binary-or-warn= is also used to evaluate if a functionality of
Cortex should be configured or not. See the example below:

#+BEGIN_EXAMPLE
(when (rrogg/eval-if-binary-or-warn "git")
  (use-package magit
    :ensure t))
#+END_EXAMPLE

* Redirect Backups and Auto-Saves

Emacs creates backups of every file currently opened and containing changes.
The filenames of those backups end with a tilde (=foo.bar~=). After some time
this feature messes uo folders very much. One can keep a clear view by
redirecting those backups to a central place where they can be accessed if
needed. Backups will be created for every file, even if they are version
controlled with git.
Auto-saves occurs if a file hasn’t been saved since a certain time
(=auto-save-timeout=) or a certain amount of typed characters
(=auto-save-interval=).
Files generated by auto-save have a leading and trailing ‘#’, eg. the auto-save
file for foo.bar is #foo.bar#. Auto-save files can be recovered with =M-x
recover-file <RET> file <RET>=.

#+BEGIN_SRC emacs-lisp
(setq auto-save-file-name-transforms
      `((".*" , (no-littering-expand-var-file-name "auto-save/") t))
      vc-make-backup-files t)
#+END_SRC

* Magit - Using git Within Emacs

| [2020-10-20] | Initial setup |

=magit= is a superb interface to =git=.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :if (rrogg/eval-if-binary-or-warn "git")
  :ensure t)
#+END_SRC

** How to Write a Good Commit Message

A good commit message follows [[https://chris.beams.io/posts/git-commit/][7 rules]]:

1. Separate subject from body with a blank line
2. Limit the subject line to 50 characters
3. Capitalize the subject line
4. Do not end the subject line with a period
5. Use the imperative mood in the subject line
6. Wrap the body at 72 characters
7. Use the body to explain what and why vs. how

For example:

#+BEGIN_EXAMPLE
Summarize changes in around 50 characters or less

More detailed explanatory text, if necessary. Wrap it to about 72
characters or so. In some contexts, the first line is treated as the
subject of the commit and the rest of the text as the body. The
blank line separating the summary from the body is critical (unless
you omit the body entirely); various tools like `log`, `shortlog`
and `rebase` can get confused if you run the two together.

Explain the problem that this commit is solving. Focus on why you
are making this change as opposed to how (the code explains that).
Are there side effects or other unintuitive consequences of this
change? Here's the place to explain them.

Further paragraphs come after blank lines.

 - Bullet points are okay, too

 - Typically a hyphen or asterisk is used for the bullet, preceded
   by a single space, with blank lines in between, but conventions
   vary here

If you use an issue tracker, put references to them at the bottom,
like this:

Resolves: #123
See also: #456, #789
#+END_EXAMPLE

All stylistic rules can be taken care of by =magit=.
It will color characters on the summary line exceeding length of 50 red and does
the same for the second line, which should be blank.
The body of the message is wrapped at length 72.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :if (rrogg/eval-if-binary-or-warn "git")
  :config
    (setq git-commit-summary-max-length 50)
    (setq git-commit-fill-column 72))
#+END_SRC

* Maximize Frame Window

The Emacs frame is maximized at all times to make use of every pixel on the
screen.

#+BEGIN_SRC emacs-lisp
(toggle-frame-maximized)
#+END_SRC

* Save Commands Across Sessions

Emacs doesn't have a persistent command history by default. The build-in history
gets resetted with every new Emacs session. The package =savehist= implements a
session independent history.

#+BEGIN_SRC emacs-lisp
(use-package savehist
  :config
  (setq savehist-file (concat no-littering-var-directory "savehist"))
  (setq savehist-save-minibuffer-history t)
  (setq history-length 1000)
  (setq history-delete-duplicates t)
  :hook (after-init-hook . savehist-mode))
#+END_SRC

* Auto Revert Mode

Ensures that (external) changes to the content of a file are updated in the
buffer of that file.

#+BEGIN_SRC emacs-lisp
(use-package autorevert
  :config
  (setq auto-revert-verbose t)
  :hook (after-init-hook . global-auto-revert-mode))
#+END_SRC

* Completion
** Orderless Completion Style
:PROPERTIES:
:ID:       51901de4-e349-4de2-9b5e-0be7da29f1ef
:END:

| [2020-12-10] | Initial setup |

The orderless completion style allows selecting candidates using strings that
appear somewhere in it. This allows to select the file =example -- tag.org= by
typing =tag= in the minibuffer. If there are multiple candidates left, =tag ex=
will select the file I want. This is helpful if I'm not completely sure what the
candidate is named exactly.


#+BEGIN_SRC emacs-lisp
(use-package orderless
  :ensure t)
#+END_SRC

** Minibuffer
This section configures the the minibuffer and how completion will be done when
in it.

Use the [[id:51901de4-e349-4de2-9b5e-0be7da29f1ef][orderless]] and partial completion styles.

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref completion-style
(setq completion-styles '(orderless partial-completion))
#+END_SRC

Completions in the minibuffer ignore case of candidates.

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref completion-ignore-case
(setq completion-ignore-case t)
(setq read-file-name-completion-ignore-case t)
(setq read-buffer-completion-ignore-case t)
#+END_SRC

Display completions sorted vertically in columns (in alphabetical order) in the
*Completions* buffer.

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref completion-buffer-format
(setq completions-format 'vertical)
#+END_SRC

#+BEGIN_SRC emacs-lisp :noweb yes
(use-package minibuffer
  :config
  <<completion-style>>
  <<completion-ignore-case>>
  <<completion-buffer-format>>)
#+END_SRC

** Visualisation of Completion Candidates - Icomplete

Let the built-in =Icomplete= handle the visualisation of completion candidates.

#+BEGIN_SRC emacs-lisp
(use-package icomplete
  :config
  (icomplete-mode t))
#+END_SRC

* PDF

Rendering PDF documents inside of Emacs enables a direct comparison of the
source material of an export and the result of the export done by Emacs (or more
specifically Org mode).
The package =pdf-tools= comes with many advantages over the built in docview.
It is based on the poppler package for Linux which will be installed by the
Emacs-package from the following source block.
The PDF document is scaled to fit the buffer it will be displayed in. Adjusting
the scaling can easily be done via =-= and =+=.

#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :ensure t
  :config
  (pdf-tools-install)
  (setq-default pdf-view-display-size 'fit-page))
#+END_SRC

* Calendar

The agenda is also used as a calendar.

** German Holidays

Information about German holidays are featured in the calendar, making it easy
to spot when Easter will be next year.

The list =calendar-holidays= contains all days of the year which I don't have be
at work. To make them show up in the agenda, the line =%%(org-calendar-holiday)=
has to appear somewhere below a heading in an org file included in the
=org-agenda-files=.

#+BEGIN_SRC emacs-lisp
(use-package holidays
  :init
  (setq calendar-holidays
          '((holiday-fixed 1 1 "Neujahr")
            (holiday-fixed 5 1 "Tag der Arbeit")
            (holiday-fixed 10 3 "Tag der Deutschen Einheit")
            (holiday-fixed 12 25 "1. Weihnachtstag")
            (holiday-fixed 12 26 "2. Weihnachtstag")
            (holiday-easter-etc  -2 "Karfreitag")
            (holiday-easter-etc  +1 "Ostermontag")
            (holiday-easter-etc +39 "Christi Himmelfahrt")
            (holiday-easter-etc +50 "Pfingstmontag")
            (holiday-easter-etc +60 "Fronleichnam")
            (holiday-fixed 11 1 "Allerheiligen"))))
#+END_SRC

** Special Dates

There are also days during the year connected to a event or special
meaning. Those days are featured in the agenda but I usually have to appear at
work that day. Therefore they should be treated a little different from actual
holidays.

Org mode (specifically =holidays.el=) supports only one list of dates to be
shown in the agenda by default (dates defined in =calendar-holidays=).
By copying and editing the three functions below, it is possible to include a
second list for special days which are not holidays in Germany.

To make them show up in the agenda, the line =%%(rrog:org-calendar-specialdate)=
has to appear somewhere in an org file included in the =org-agenda-files=.

#+BEGIN_SRC emacs-lisp
(defun rrogg/org-calendar-specialdate ()
  "List of special dates, for Diary display in Org mode."
  (require 'holidays)
  (let ((hl (rrogg/calendar-check-specialdates org-agenda-current-date)))
    (and hl (mapconcat #'identity hl "; "))))

(defun rrogg/calendar-check-specialdates (date)
  "Check the list of special dates for any that occur on DATE.
DATE is a list (month day year).  This function considers the
special dates from the list `calendar-specialdates', and returns a list of
strings describing those special dates that apply on DATE, or nil if none do."
  (let ((displayed-month (calendar-extract-month date))
        (displayed-year (calendar-extract-year date))
        specialdate-list)
    (dolist (h (rrogg/calendar-specialdate-list) specialdate-list)
      (if (calendar-date-equal date (car h))
          (setq specialdate-list (append specialdate-list (cdr h)))))))

(defun rrogg/calendar-specialdate-list ()
  "Form the list of special dates that occur on dates in the calendar window.
The special dates are those in the list `calendar-specialdates'."
  (let (res h err)
    (sort
     (dolist (p rrogg/calendar-specialdates res)
       (if (setq h (if calendar-debug-sexp
                       (let ((debug-on-error t))
                         (eval p))
                     (condition-case err
                         (eval p)
                       (error
                        (display-warning
                         'specialdays
                         (format "Bad specialdate list item: %s\nError: %s\n"
                                 p err)
                         :error)
                        nil))))
           (setq res (append h res))))
     'calendar-date-compare)))

(setq rrogg/calendar-specialdates
            '((holiday-float 5 0 2 "Muttertag")
              (holiday-float 6 0 3 "Vatertag")
              (holiday-float 12 0 -4 "1. Advent" 24)
              (holiday-float 12 0 -3 "2. Advent" 24)
              (holiday-float 12 0 -2 "3. Advent" 24)
              (holiday-float 12 0 -1 "4. Advent" 24)
              (holiday-fixed 12 24 "Heiligabend")
              (holiday-fixed 1 6 "Heilige Drei Könige")
              (holiday-easter-etc -52 "Weiberfastnacht")
              (holiday-easter-etc -50 "Karnevalssamstag")
              (holiday-easter-etc -49 "Karnevalssonntag")
              (holiday-easter-etc -48 "Rosenmontag")
              (holiday-easter-etc -47 "Veilchendienstag")
              (holiday-easter-etc -46 "Aschermittwoch")
              (holiday-easter-etc -3 "Gründonnerstag")
              (holiday-easter-etc   0 "Ostersonntag")
              (holiday-easter-etc +49 "Pfingstsonntag")
              (holiday-fixed 8 15 "Mariae Himmelfahrt")
              (holiday-fixed 11 11 "Martinstag")
              (holiday-fixed 11 11 "Elfter im Elften")
              (holiday-float 11 3 1 "Buss- und Bettag" 16)
              (holiday-float 11 0 1 "Totensonntag" 20)))
#+END_SRC

** Solar Calendar

Emacs can calculate the time of sunrise, sundown and also other events based on
the position of the sun. In order to ensure that this calculations are correct,
latitude, longitude and location name need to be adjusted to the current
position on earth.

#+BEGIN_SRC emacs-lisp
(use-package solar
  :config
  (setq calendar-latitude [51 14 north])
  (setq calendar-longitude [6 47 east])
  (setq calendar-location-name "Düsseldorf, NRW"))
#+END_SRC

Those solar events shall be categorized independently from other calendar
entries. This gives free choice on if and how this gets integrated into the
agenda.

Similar to the special dates solar dates show up in the agenda by including the
line =%%(rrogg/org-calendar-solar)= somewhere in one of the =org-agenda-files=.

#+BEGIN_SRC emacs-lisp
(defun rrogg/org-calendar-solar ()
  "List of solar dates, for Diary display in Org mode."
  (require 'holidays)
  (let ((hl (rrogg/calendar-check-solar org-agenda-current-date)))
    (and hl (mapconcat #'identity hl "; "))))

(defun rrogg/calendar-check-solar (date)
  "Check the list of solar for any that occur on DATE.
DATE is a list (month day year).  This function considers the
special dates from the list `calendar-solar', and returns a list of
strings describing those solar that apply on DATE, or nil if none do."
  (let ((displayed-month (calendar-extract-month date))
        (displayed-year (calendar-extract-year date))
        solar-list)
    (dolist (h (rrogg/calendar-solar-list) solar-list)
      (if (calendar-date-equal date (car h))
          (setq solar-list (append solar-list (cdr h)))))))

(defun rrogg/calendar-solar-list ()
  "Form the list of solar that occur on dates in the calendar window.
The solar are those in the list `calendar-solar'."
  (let (res h err)
    (sort
     (dolist (p rrogg/calendar-solar res)
       (if (setq h (if calendar-debug-sexp
                       (let ((debug-on-error t))
                         (eval p))
                     (condition-case err
                         (eval p)
                       (error
                        (display-warning
                         'solar
                         (format "Bad solar list item: %s\nError: %s\n"
                                 p err)
                         :error)
                        nil))))
           (setq res (append h res))))
     'calendar-date-compare)))

(setq rrogg/calendar-solar
            '((holiday-sexp calendar-daylight-savings-starts
	       (format "Beginn der Sommerzeit – die Uhr wird um eine Stunde vorgestellt %s"
		       (solar-time-string
			(/ calendar-daylight-savings-starts-time . #1=((float 60)))
			calendar-standard-time-zone-name)))
              (holiday-sexp calendar-daylight-savings-ends
	       (format "Ende der Sommerzeit – die Uhr wird um eine Stunde zurückgestellt %s"
		       (solar-time-string
			(/ calendar-daylight-savings-ends-time . #1#)
			calendar-daylight-time-zone-name)))))
#+END_SRC

* Org Mode

Org mode is right at the core of Cortex. It's the glue which connects task
management, literate programming, contact managment, dealing with mail,
composing and exporting text and many more things.

** General Settings

All files of type =.org= or =.org_archive= are automatically opened with Org
mode activated within Emacs.
A lot of helpful packages are contributed to the Org mode source. To ensure that
they are installed by Cortex, Org mode is retrieved from the =orgmode.org/elpa=
repository.
The indicator for a collapsed heading with an existing body of text
(=org-ellipsis=) is changed to =" ⤵"= , which is a more unique and intuitiv then
the standard ="..."=.

#+BEGIN_SRC emacs-lisp
(use-package org
  :mode (("\\.\\(org\\|org_archive\\)$" . org-mode))
  :ensure org-plus-contrib
  :config
  (defvar rrogg/org-config-start-time (current-time) "Time when my org-mode config was started")
  (message "★→ Org mode")
  (rrogg/cortex-log-hostspecific "org-version" org-version)
  (setq org-ellipsis " ⤵"))
#+END_SRC

Indentation of text below a heading up to the last star (=*=) of the heading is
enabled. All leading stars are hidden.
This can be turned off on a per file basis by putting =#+STARTUP: noindent= at
the start of the file.
Only major headings are shown as folded on startup.
Start a new line after a heading at the beginning of the line, no indentation.

#+BEGIN_SRC emacs-lisp
(use-package org
  :config
  (setq org-startup-indented t)
  (setq org-startup-folded t)
  (setq org-adapt-indentation nil))
#+END_SRC

** Clearly Identifiable Org Headings

In order to make a link to an org heading independent from the location of that
heading, =org-id= takes care of creating an unique identifier for a heading, if
a link to it gets stored (=org-store-link=) and there is no ID present for it.
Having point anywhere on the body of an org heading, invoking =C-c l= will do
the above. =C-c C-l= can be invoked to insert a link to an org entry.

There is an issue with an niche case: If =org-store-link= is called from a
fresh Emacs session, it won't create an =:ID:= property when point is on a
heading without one. Invoking =(featurep 'org-id)= returns nil, so org-id is not
started. This might be caused by =use-package=. The =org-id= module is only
loaded if one of its commands is called. =org-store-link= only checks if
=org-id-link-to-org-use-id= is non-nil, but it won't see it because it has not
been loaded yet. One could solve this issue by adding a =(require 'org-id)= to
the source block below. This is annoying, so I'll go with the ugly fix.

When point is on a link, =RET= will follow it.

#+BEGIN_SRC emacs-lisp
(use-package org
  :config
  (require 'org-id)
  (setq org-id-method 'uuid)
  (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)
  (setq org-return-follows-link t)
  :bind ("C-c l" . org-store-link))
#+END_SRC

** Tasks and States

#+BEGIN_SRC emacs-lisp
(use-package org
  :config
  (setq org-todo-keywords
        '((sequence "NEXT(n)" "WAITING(w)" "CALL(c)" "VISIT(v)" "TRAVEL(t)" "PLANNING(p)" "STARTED(s)" "HOLD(h)" "|" "DONE(d)" "CANCELLED(C)" "NOPART(N)")))
  (setq org-use-fast-todo-selection t)
  (setq org-treat-S-cursor-todo-selection-as-state-change nil))
#+END_SRC

*** Tasks

A task is the basic form of a thing that can be done.
It can have unique states which are covered below:

- =NEXT= tasks are things that I can work on right now; they are not blocked by anything and can be
  picked up right away.
- =WAITING= tasks are things that are waiting on the completion of other tasks,
  be it my own or external.
- =DONE= tasks that are complete and ready for archiving.
- =CANCELLED= tasks are aborted and won't be completed.

*** Projects

A grouping of tasks towards a certain goal is a project; write an Emacs
configuration, raise a family, build a new shelve for the basement.
The heading under which all those tasks can be grouped, is representative for
the project and can have following states:

- =PLANNING= A project that is still brainstormed, not fully flashed
  out. Sometimes it exists only in the form of a few ideas. No actual work has
  been done in order to progress towards a goal.
- =STARTED= Projects that have been worked on.
- =HOLD= Projects that are on hold.
- =DONE= Projects that reached the defined goal. There might be projects which
  naturally can't reach that state.
- =CANCELLED= Projects that are abandoned and won't be completed.

*** Calls

I collect phone calls and conference calls ("meetings") under this
keyword. Calls can be spontaneous or scheduled.

- =CALL= Calls that are scheduled or happened adhoc.
- =DONE= Calls that happened and I participated in.
- =CANCELLED= Cancelled calls that are not moved.
- =NOPART= Calls that I did not participate in.

*** Visits

Physical meetings are assigned with this keyword. A visit usually requires me to
change my location, because they are not virtual meetings. Visits can also be
events like concerts, trade shows. Visits have the same states as the very
similar keyword calls.

- =VISIT= Visits that are scheduled.
- =DONE= Visits that happened and I participated in.
- =CANCELLED= Cancelled visits that are not moved.
- =NOPART= Visits that I did not participate in.

*** Travels

Traveling from one place to another by bike, car, train, plane, boat or even by
walking is marked with this keyword.

- =TRAVEL= A block of time for getting from A to B.
- =DONE= That trip has been completed.
- =CANCELLED= The trip has been cancelled.

** Capture New Items

Getting information into Org mode has to be fast and easy. A convenient way to
create items is to use =org-capture=.
Called by pressing =C-c c=, =org-capture= shows a menu from which a template
specifically tailored to the information to be entered can be selected.
Selecting a single destination for those captured items is sometimes quite hard,
especially for tasks, which can belong to different contexts like projects, work
related things or private activities. Choosing the final destination for a
captured item during the capture process most often slows the process down to
much. I want to get information out of my head into the system fast, so I can
move on and deal with other things. Therefore all captures shall be collected
at a single place by default. The items in there get refiled in another
process independent from the capture process. This place saved in the
=org-default-notes-file= variable, which points to my =refile.org= file.

#+BEGIN_SRC emacs-lisp
(use-package org
  :config
  (setq org-directory "~/org/")
  (setq org-default-refile-file (concat org-directory "refile.org"))
  (setq org-default-notes-file (concat org-directory "notes.org"))
  :bind ("C-c c" . org-capture))
#+END_SRC

*** Template: Tasks

The default task tracking template will stick the item into =refile= with the
=NEXT= state. The task state can be changed if that isn't accurate, but for most
things that are going to be captured it is fine using this.
A link to the headline from which =org-capture= was called from, is stored via
=%a=. If that heading doesn't have a ID yet, it is advised to call =C-c l=
(=org-store-link=) first. This will prevent fragile links by using =org-id=
based links.

#+BEGIN_SRC emacs-lisp
(setq rrogg/capture-template-task "* NEXT %?
:LOGBOOK:
:CREATED: %U
:END:
%a


")
#+END_SRC

*** Template: Calls

Calls have a active time stamp in their heading, which will be recognized by
=org-agenda=.

#+BEGIN_SRC emacs-lisp
(setq rrogg/capture-template-call "* CALL %(org-time-stamp nil) %?
:LOGBOOK:
:CREATED: %U
:END:


")
#+END_SRC

*** Template: Notes

Notes come in the form of ideas, small snippets of code with a short
documentation, bits of information worth to be remembered and
learnings. Combined, those can be reforged into an engineers workbook, serve as
basis for researching a given topic further and other things.
I still have to explore the direction I want to go with this. Something like a
Zettelkasten or a recreation of Roam Research seems very interesting. In the end
it all comes down to how quick information can be pulled out of the system.
For a start, this right here is about getting information into it.

#+BEGIN_SRC emacs-lisp
(setq rrogg/capture-template-note "* %?
:LOGBOOK:
:CREATED: %U
:END:


")
#+END_SRC

*** Template: Contacts

Essential contact information is first name, family name, birthday and e-mail
address. Birthday and e-mail address have to be treated specially, because those
properties break the org-agenda if not present or in the wrong format.

#+BEGIN_SRC emacs-lisp
(setq rrogg/capture-template-contact "* %?
:PROPERTIES:
:BIRTHDAY: 
:EMAIL: 
:END:
:LOGBOOK:
:CREATED: %U
:END:

")
#+END_SRC

*** Calling Capture Templates

The templates created earlier can be selected by invoking =C-c c= followed by
the letter designated for a certain template (e.g. =C-c c c= for capturing
contact information).
After the capture process is completed for an item, a unique ID is created and
attached to it.

 #+BEGIN_SRC emacs-lisp
 (use-package org
   :config
   (setq org-capture-templates `(("t" "Task" entry (file org-default-refile-file)
                                  ,rrogg/capture-template-task)
                                 ("c" "Call" entry (file org-default-refile-file)
                                  ,rrogg/capture-template-call)
                                 ("C" "Contact" entry (file org-default-refile-file)
                                  ,rrogg/capture-template-contact)
                                 ("n" "Note" entry (file org-default-notes-file)
                                  ,rrogg/capture-template-note)))
  :hook (org-capture-prepare-finalize-hook . org-id-get-create))
#+END_SRC

** Organize Captured Items

All captured items get created in the =org-default-notes-file= and are refiled
from there.
Invoking =C-c C-w= starts the refile process. Possible targets are all
=org-agenda-files= with headings up to 9 levels deep.
The refile process is allowed to create parent tasks with confirmation.
A time stamp is created on completion of the refile process for an item and
logged into the item's logbook drawer.

#+BEGIN_SRC emacs-lisp
  (use-package org
    :config
    (setq org-refile-targets '((nil :maxlevel . 9)
			       (org-agenda-files :maxlevel . 9)))
    (setq org-refile-use-outline-path 'file)
    ;; (setq org-outline-path-complete-in-steps nil)
    (setq org-refile-allow-creating-parent-nodes '(confirm))
    (setq org-log-refile 'time)
    (setq org-log-into-drawer t))
#+END_SRC

** Contacts

=org-contacts= takes care of managing contact information of family, friends,
co-workers, business contacts, venues, stores etc.
All this information gets stored in one org file, which has to be known to
org-contacts.
In order to include birthdays of contacts to the agenda, this file
also has to be included in the =org-agenda-files=. Birthdays will show up, if
the following line appears somewhere in an agenda file:

#+BEGIN_EXAMPLE
%%(org-contacts-anniversaries)
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
(use-package org-contacts
  :config
  (setq org-contacts-files '("~/org/contacts.org")))
#+END_SRC

*** Additional Anniversaries

To add support for other anniversaries like wedding days, date of death or other
special dates belonging to a contact or group while displaying those dates in a
individual category on the agenda, some of the code in =org-contacts.el= has to
be copied and slightly modified.

Those dates can be included into the agenda by adding the following to an org
agenda file:

#+BEGIN_EXAMPLE
%%(rrogg/org-contacts-wedding-anniversaries)
#+END_EXAMPLE

This way org-contacts also supports:

**** Church Wedding Dates

#+BEGIN_SRC emacs-lisp
(defun rrogg/org-contacts-wedding-anniversaries (&optional field format)
  "Compute FIELD wedding-anniversary for each contact, returning FORMAT.
Default FIELD value is \"WEDDINGDAY\".

Format is a string matching the following format specification:

  %h - Heading name
  %l - Link to the heading
  %y - Number of year
  %Y - Number of year (ordinal)"
  (let ((calendar-date-style 'american)
        (entry ""))
    (unless format (setq format rrogg/org-contacts-weddingday-format))
    (cl-loop for contact in (org-contacts-filter)
	     for anniv = (let ((anniv (cdr (assoc-string
					    (or field rrogg/org-contacts-weddingday-property)
					    (nth 2 contact)))))
			   (when anniv
			     (calendar-gregorian-from-absolute
			      (org-time-string-to-absolute anniv))))
	     ;; Use `diary-anniversary' to compute anniversary.
	     if (and anniv (apply 'diary-anniversary anniv))
	     collect (format-spec format
				  `((?l . ,(org-with-point-at (cadr contact) (org-store-link nil)))
				    (?h . ,(car contact))
				    (?y . ,(- (calendar-extract-year date)
					      (calendar-extract-year anniv)))
				    (?Y . ,(let ((years (- (calendar-extract-year date)
							   (calendar-extract-year anniv))))
					     (format "%d%s" years (diary-ordinal-suffix years)))))))))

(defcustom rrogg/org-contacts-weddingday-property "WEDDINGDAY"
  "Name of the property for contact weddingday date."
  :type 'string
  :group 'org-contacts)

(defcustom rrogg/org-contacts-weddingday-format "Wedding Anniv.: %l (%Y)"
  "Format of the anniversary agenda entry.
The following replacements are available:

  %h - Heading name
  %l - Link to the heading
  %y - Number of year
  %Y - Number of year (ordinal)"
  :type 'string
  :group 'org-contacts)
#+END_SRC

**** Civil Wedding Dates

#+BEGIN_SRC emacs-lisp
(defun rrogg/org-contacts-civil-wedding-anniversaries (&optional field format)
  "Compute FIELD civil-wedding-anniversary for each contact, returning FORMAT.
Default FIELD value is \"CIVILWEDDINGDAY\".

Format is a string matching the following format specification:

  %h - Heading name
  %l - Link to the heading
  %y - Number of year
  %Y - Number of year (ordinal)"
  (let ((calendar-date-style 'american)
        (entry ""))
    (unless format (setq format rrogg/org-contacts-civil-weddingday-format))
    (cl-loop for contact in (org-contacts-filter)
	     for anniv = (let ((anniv (cdr (assoc-string
					    (or field rrogg/org-contacts-civil-weddingday-property)
					    (nth 2 contact)))))
			   (when anniv
			     (calendar-gregorian-from-absolute
			      (org-time-string-to-absolute anniv))))
	     ;; Use `diary-anniversary' to compute anniversary.
	     if (and anniv (apply 'diary-anniversary anniv))
	     collect (format-spec format
				  `((?l . ,(org-with-point-at (cadr contact) (org-store-link nil)))
				    (?h . ,(car contact))
				    (?y . ,(- (calendar-extract-year date)
					      (calendar-extract-year anniv)))
				    (?Y . ,(let ((years (- (calendar-extract-year date)
							   (calendar-extract-year anniv))))
					     (format "%d%s" years (diary-ordinal-suffix years)))))))))

(defcustom rrogg/org-contacts-civil-weddingday-property "CIVILWEDDINGDAY"
  "Name of the property for contact civil weddingday date."
  :type 'string
  :group 'org-contacts)

(defcustom rrogg/org-contacts-civil-weddingday-format "Civil Wedding Anniv.: %l (%Y)"
  "Format of the anniversary agenda entry.
The following replacements are available:

  %h - Heading name
  %l - Link to the heading
  %y - Number of year
  %Y - Number of year (ordinal)"
  :type 'string
  :group 'org-contacts)
#+END_SRC

**** Date Since When Contact is Known

#+BEGIN_SRC emacs-lisp
(defun rrogg/org-contacts-first-met-anniversaries (&optional field format)
  "Compute FIELD first-met-anniversary for each contact, returning FORMAT.
Default FIELD value is \"FIRSTMET\".

Format is a string matching the following format specification:

  %h - Heading name
  %l - Link to the heading
  %y - Number of year
  %Y - Number of year (ordinal)"
  (let ((calendar-date-style 'american)
        (entry ""))
    (unless format (setq format rrogg/org-contacts-first-met-format))
    (cl-loop for contact in (org-contacts-filter)
	     for anniv = (let ((anniv (cdr (assoc-string
					    (or field rrogg/org-contacts-first-met-property)
					    (nth 2 contact)))))
			   (when anniv
			     (calendar-gregorian-from-absolute
			      (org-time-string-to-absolute anniv))))
	     ;; Use `diary-anniversary' to compute anniversary.
	     if (and anniv (apply 'diary-anniversary anniv))
	     collect (format-spec format
				  `((?l . ,(org-with-point-at (cadr contact) (org-store-link nil)))
				    (?h . ,(car contact))
				    (?y . ,(- (calendar-extract-year date)
					      (calendar-extract-year anniv)))
				    (?Y . ,(let ((years (- (calendar-extract-year date)
							   (calendar-extract-year anniv))))
					     (format "%d%s" years (diary-ordinal-suffix years)))))))))

(defcustom rrogg/org-contacts-first-met-property "FIRSTMET"
  "Name of the property for contact firstmet date."
  :type 'string
  :group 'org-contacts)

(defcustom rrogg/org-contacts-first-met-format "First Met Anniv.: %l (%Y)"
  "Format of the anniversary agenda entry.
The following replacements are available:

  %h - Heading name
  %l - Link to the heading
  %y - Number of year
  %Y - Number of year (ordinal)"
  :type 'string
  :group 'org-contacts)
#+END_SRC

**** Date the Relationship With That Contact Started

#+BEGIN_SRC emacs-lisp
(defun rrogg/org-contacts-relationshipday-anniversaries (&optional field format)
  "Compute FIELD relationshipday-anniversary for each contact, returning FORMAT.
Default FIELD value is \"RELATIONSHIPDAY\".

Format is a string matching the following format specification:

  %h - Heading name
  %l - Link to the heading
  %y - Number of year
  %Y - Number of year (ordinal)"
  (let ((calendar-date-style 'american)
        (entry ""))
    (unless format (setq format rrogg/org-contacts-relationshipday-format))
    (cl-loop for contact in (org-contacts-filter)
	     for anniv = (let ((anniv (cdr (assoc-string
					    (or field rrogg/org-contacts-relationshipday-property)
					    (nth 2 contact)))))
			   (when anniv
			     (calendar-gregorian-from-absolute
			      (org-time-string-to-absolute anniv))))
	     ;; Use `diary-anniversary' to compute anniversary.
	     if (and anniv (apply 'diary-anniversary anniv))
	     collect (format-spec format
				  `((?l . ,(org-with-point-at (cadr contact) (org-store-link nil)))
				    (?h . ,(car contact))
				    (?y . ,(- (calendar-extract-year date)
					      (calendar-extract-year anniv)))
				    (?Y . ,(let ((years (- (calendar-extract-year date)
							   (calendar-extract-year anniv))))
					     (format "%d%s" years (diary-ordinal-suffix years)))))))))

(defcustom rrogg/org-contacts-relationshipday-property "RELATIONSHIPDAY"
  "Name of the property for contact realtionshipday date."
  :type 'string
  :group 'org-contacts)

(defcustom rrogg/org-contacts-relationshipday-format "Realationship Anniv.: %l (%Y)"
  "Format of the anniversary agenda entry.
The following replacements are available:

  %h - Heading name
  %l - Link to the heading
  %y - Number of year
  %Y - Number of year (ordinal)"
  :type 'string
  :group 'org-contacts)
#+END_SRC

**** Date of Proposal

#+BEGIN_SRC emacs-lisp
(defun rrogg/org-contacts-proposalday-anniversaries (&optional field format)
  "Compute FIELD proposalday-anniversary for each contact, returning FORMAT.
Default FIELD value is \"PROPOSALDAY\".

Format is a string matching the following format specification:

  %h - Heading name
  %l - Link to the heading
  %y - Number of year
  %Y - Number of year (ordinal)"
  (let ((calendar-date-style 'american)
        (entry ""))
    (unless format (setq format rrogg/org-contacts-proposalday-format))
    (cl-loop for contact in (org-contacts-filter)
	     for anniv = (let ((anniv (cdr (assoc-string
					    (or field rrogg/org-contacts-proposalday-property)
					    (nth 2 contact)))))
			   (when anniv
			     (calendar-gregorian-from-absolute
			      (org-time-string-to-absolute anniv))))
	     ;; Use `diary-anniversary' to compute anniversary.
	     if (and anniv (apply 'diary-anniversary anniv))
	     collect (format-spec format
				  `((?l . ,(org-with-point-at (cadr contact) (org-store-link nil)))
				    (?h . ,(car contact))
				    (?y . ,(- (calendar-extract-year date)
					      (calendar-extract-year anniv)))
				    (?Y . ,(let ((years (- (calendar-extract-year date)
							   (calendar-extract-year anniv))))
					     (format "%d%s" years (diary-ordinal-suffix years)))))))))

(defcustom rrogg/org-contacts-proposalday-property "PROPOSALDAY"
  "Name of the property for contact proposalday date."
  :type 'string
  :group 'org-contacts)

(defcustom rrogg/org-contacts-proposalday-format "Proposal Anniv.: %l (%Y)"
  "Format of the anniversary agenda entry.
The following replacements are available:

  %h - Heading name
  %l - Link to the heading
  %y - Number of year
  %Y - Number of year (ordinal)"
  :type 'string
  :group 'org-contacts)
#+END_SRC

**** Date the Contact Passed Away

#+BEGIN_SRC emacs-lisp
(defun rrogg/org-contacts-dayofdeath-anniversaries (&optional field format)
  "Compute FIELD dayofdeath-anniversary for each contact, returning FORMAT.
Default FIELD value is \"DAYOFDEATH\".

Format is a string matching the following format specification:

  %h - Heading name
  %l - Link to the heading
  %y - Number of year
  %Y - Number of year (ordinal)"
  (let ((calendar-date-style 'american)
        (entry ""))
    (unless format (setq format rrogg/org-contacts-dayofdeath-format))
    (cl-loop for contact in (org-contacts-filter)
	     for anniv = (let ((anniv (cdr (assoc-string
					    (or field rrogg/org-contacts-dayofdeath-property)
					    (nth 2 contact)))))
			   (when anniv
			     (calendar-gregorian-from-absolute
			      (org-time-string-to-absolute anniv))))
	     ;; Use `diary-anniversary' to compute anniversary.
	     if (and anniv (apply 'diary-anniversary anniv))
	     collect (format-spec format
				  `((?l . ,(org-with-point-at (cadr contact) (org-store-link nil)))
				    (?h . ,(car contact))
				    (?y . ,(- (calendar-extract-year date)
					      (calendar-extract-year anniv)))
				    (?Y . ,(let ((years (- (calendar-extract-year date)
							   (calendar-extract-year anniv))))
					     (format "%d%s" years (diary-ordinal-suffix years)))))))))

(defcustom rrogg/org-contacts-dayofdeath-property "DAYOFDEATH"
  "Name of the property for contact day of death date."
  :type 'string
  :group 'org-contacts)

(defcustom rrogg/org-contacts-dayofdeath-format "Anniv. of Death: %l (%Y)"
  "Format of the anniversary agenda entry.
The following replacements are available:

  %h - Heading name
  %l - Link to the heading
  %y - Number of year
  %Y - Number of year (ordinal)"
  :type 'string
  :group 'org-contacts)
#+END_SRC

** Agenda

The agenda is the central dashboard showing an overview of tasks. That my be all
my work related tasks for a day, my meeting appointments for the next week or
the tasks belonging to a private project. Invoking =C-c a= anywhere in Emacs
will show the main menu of the agenda feature of Org mode.

All org files specified in the variable =org-agenda-files= contribute to the
agenda.

#+BEGIN_SRC emacs-lisp
(use-package org
  :config
  (setq org-agenda-files '("~/org/refile.org" "~/org/work.org" "~/org/private.org"))
  :bind ("C-c a" . org-agenda))
#+END_SRC

*** Show Small Icons in Agenda View

Some agenda entries belonging to a certain category have a small 16 x 16 pixel
icon assigned to them. If the entries category has no icon assigned, it is
displayed 16 pixels further right.

The icons are stored in =~/templates_labels/icons/=.

#+BEGIN_SRC emacs-lisp
(use-package org
  :config
  (setq org-agenda-category-icon-alist
    '(("\\(Holiday\\|Vacation\\)" "~/templates_labels/icons/holiday.png" nil nil :ascent center)
      ("Anniv." "~/templates_labels/icons/anniversary.png" nil nil :ascent center)
      ("Spec. Date" "~/templates_labels/icons/specialdate.png" nil nil :ascent center)
      ("Time" "~/templates_labels/icons/time.png" nil nil :ascent center)
      ("Marriage" "~/templates_labels/icons/marriage.gif" nil nil :ascent center)
      ("Love" "~/templates_labels/icons/love.png" nil nil :ascent center)
      ("Mourning" "~/templates_labels/icons/mourning.png" nil nil :ascent center)
      (".*" '(space . (:width (16)))))))
#+END_SRC

** Org Mode Config Finished

#+BEGIN_SRC emacs-lisp
(message "→★ Org mode finished in %.2fs" (float-time (time-subtract (current-time) rrogg/org-config-start-time)))
#+END_SRC

* Final Spurt

This is the end of Cortex. Let's see how much time it took to load all of the
shenanigans. Write the result to the =Messages= buffer.
List missing binaries needed for certain functionality of Cortex. 

#+BEGIN_SRC emacs-lisp
(message "→★ Finished loading Cortex in %.2fs" (float-time (time-subtract (current-time) rrogg/cortex-start-time)))
(message "»»» Binaries not found in checks above: %s\n" rrogg/binary-not-found-list)
#+END_SRC
