#+TITLE: CORTEX - AN EMACS CONFIGURATION
#+PROPERTY: header-args :result silent :tangle "~/.emacs.d/init.el" :eval no-export :comments org
:PROPERTIES:
:ID:       a6abcbf1-f6b9-483d-a458-bb981b05cb19
:END:

* Track Loading Time of Cortex

Starting Emacs has to be as quick as possible. In order to evaluate the time it
takes to load Cortex, someone has to blow the whistle and start the stopwatch.

#+BEGIN_SRC emacs-lisp
(defvar rrogg/cortex-start-time (current-time) "Time when Cortex was started")
(message "\n★→ Cortex")
#+END_SRC

The start time is also used in logs. The format of the time string is different
from =rrogg/cortex-start-time=.

#+BEGIN_SRC emacs-lisp
(setq rrogg/cortex-start-time-iso (format-time-string "%Y-%m-%dT%T"))
#+END_SRC

* Server Start

Emacs offers a server mode, which allows to open additional from outside of
Emacs in the same session that is already running. No need to open a file in
another Emcas and reload the complete config again for it.

#+BEGIN_SRC emacs-lisp
(server-start)
#+END_SRC

* Support for Non-Linux Systems

** Windows

*** Installation
Emacs is installed from chocolatey via =cmd.exe=:

#+BEGIN_EXAMPLE
choco install emacs
#+END_EXAMPLE

The environment variable =HOME= does not exist by default, so it needs to be
created manually:

#+BEGIN_EXAMPLE
This PC (right-click)
-> Properties
-> Computer name, domain, and workgroup settings
-> Change settings
-> Advanced
-> Environment Variables...
-> New
HOME C:\home\rrogg
#+END_EXAMPLE

On first start of Emacs, the =~/.emacs.d/= directory gets created automatically.

*** Cloning Cortex Repository

In order to clone the Cortex repository, install =git= from =chocolatey= via
=cmd.exe=:

#+BEGIN_EXAMPLE
choco install git
#+END_EXAMPLE

=git= should be automatically found by Emacs, no need to add it to the path.

Clone Cortex via =git bash=:

#+BEGIN_EXAMPLE
cd ~/src
git clone https://github.com/rrogg/cortex.git
#+END_EXAMPLE

*** General Issues

**** =~/.emacs.d/server/= unsafe location

Emacs complaints about =~/.emacs.d/server/= not beeing a safe loacation (magit,
server-start).
This is resolved by changing the access rights to that folder via =cmd.exe=:

#+BEGIN_EXAMPLE
cd %HOME%\.emacs.d
takeown /f server
#+END_EXAMPLE

**** Attach Files to Already Open Emacs Session

When Emacs is started as a daemon (=(server-start)=), all additionaly opened
files should be openend within the current session and not in a seperate
instance of Emacs. That instance would load Cortex again, which takes time. The
buffer list is also not shared between those instances.

Emacs on Windows comes with several execuatables, of which I use two:

- =runemacs.exe=
- =emacsclientw.exe=

Should Emacs not be started, e.g. after a reboot, I use =runemacs.exe= to do so.
Loading Cortex, Emacs will create a daemon in the background, to which other
files can be attached when they are opened.
Opening files is either done directly from within Emacs or by opening them from
a folder.
In order to always attach those externaly opened files to the running session, I
use =emacsclientw.exe= with some parameters. It needs a file name to open in order to
start Emacs, so I can't use it to start Emacs in a way that it always does what
I want.
The =Target= value of the shortcut is the following:

#+BEGIN_EXAMPLE
C:\ProgramData\chocolatey\bin\emacsclientw.exe -n -a ""
#+END_EXAMPLE

If there is a Emacs server running, it will open the file in the current
session. If no server has been started yet, it will do so (=-a ""=).

Now this shortcut has to be set as default programm to open the specific file
extension with. This has to be done once per file extension.
I created the shortcut in =C:\ProgramData\Microsoft\Windows\Start Menu\Programs=.
It could also be set via Windows Registry, but I failed to add more file
extensions to the =.reg= file. This file just needs to be executed and it will
set the default programm.

#+BEGIN_EXAMPLE
Windows Registry Editor Version 5.00
[HKEY_CURRENT_USER\Software\Classes\texfile]
[HKEY_CURRENT_USER\Software\Classes\texfile\Shell]
[HKEY_CURRENT_USER\Software\Classes\texfile\Shell\Open]
[HKEY_CURRENT_USER\Software\Classes\texfile\Shell\Open\Command]
@="C:\\ProgramData\\chocolatey\\bin\\emacsclientw.exe -n -a \"C:\\ProgramData\\chocolatey\\bin\\runemacs.exe\" \"%1\" %*"
[HKEY_CURRENT_USER\Software\Classes\.tex]
@="texfile"
[HKEY_CURRENT_USER\Software\Classes\.bib]
@="texfile"
[HKEY_CURRENT_USER\Software\Classes\.lco]
@="texfile"
[HKEY_CURRENT_USER\Software\Classes\.sty]
@="texfile"
[HKEY_CURRENT_USER\Software\Classes\.cls]
@="texfile"
[HKEY_CURRENT_USER\Software\Classes\txtfile]
[HKEY_CURRENT_USER\Software\Classes\txtfile\Shell]
[HKEY_CURRENT_USER\Software\Classes\txtfile\Shell\Open]
[HKEY_CURRENT_USER\Software\Classes\txtfile\Shell\Open\Command]
@="C:\\ProgramData\\chocolatey\\bin\\emacsclientw.exe -n -a \"C:\\ProgramData\\chocolatey\\bin\\runemacs.exe\" \"%1\" %*"
[HKEY_CURRENT_USER\Software\Classes\.txt]
@="txtfile"
[HKEY_CURRENT_USER\Software\Classes\.org]
@="txtfile"
[HKEY_CURRENT_USER\Software\Classes\scriptfile]
[HKEY_CURRENT_USER\Software\Classes\scriptfile\Shell]
[HKEY_CURRENT_USER\Software\Classes\scriptfile\Shell\Open]
[HKEY_CURRENT_USER\Software\Classes\scriptfile\Shell\Open\Command]
@="C:\\ProgramData\\chocolatey\\bin\\emacsclientw.exe -n -a \"C:\\ProgramData\\chocolatey\\bin\\runemacs.exe\" \"%1\" %*"
[HKEY_CURRENT_USER\Software\Classes\.sh]
@="scriptfile"
[HKEY_CURRENT_USER\Software\Classes\cfile]
[HKEY_CURRENT_USER\Software\Classes\cfile\Shell]
[HKEY_CURRENT_USER\Software\Classes\cfile\Shell\Open]
[HKEY_CURRENT_USER\Software\Classes\cfile\Shell\Open\Command]
@="C:\\ProgramData\\chocolatey\\bin\\emacsclientw.exe -n -a \"C:\\ProgramData\\chocolatey\\bin\\runemacs.exe\" \"%1\" %*"
[HKEY_CURRENT_USER\Software\Classes\.c]
@="cfile"
[HKEY_CURRENT_USER\Software\Classes\.h]
@="cfile"
#+END_EXAMPLE

* Disable GUI components

Display no GUI components other than the =modline=.

#+BEGIN_SRC emacs-lisp
(use-package emacs
  :init
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1))
#+END_SRC

* Wrap Lines at a Reasonable Width

Long lines of text have to be wrapped at a width of 80 characters. In order to
leave long code lines untouched, automatic line wrap is only active in
=text-mode= and modes which inherit from =text-mode=, like e.g. =org-mode=.

#+BEGIN_SRC emacs-lisp
(setq-default fill-column 80)
(add-hook 'text-mode-hook 'auto-fill-mode)
#+END_SRC

* Stop the Bell

Acoustic feedback is not wanted for this system. Therefore stop ringing the bell!

#+BEGIN_SRC emacs-lisp
(setq ring-bell-function #'ignore)
#+END_SRC

* Hide Welcome Screen and Empty =*scratch*=

Emacs shows a splash screen at startup from which one can easily get to the
tutorial. While helpful in the beginning, this screen gets abdicable with
time. Therefore it's disabled.
Emacs also automatically loads a buffer called =*scratch*=, which serves as a
place to try out emacs lisp code or to type out some ideas. This is very helpful
as one doesn't have to think about creating a new file for every unrelated
thought. The welcome message isn't needed, so it gets disabled.

#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t)
(setq initial-scratch-message nil)
#+END_SRC

* Force a Sane Coding System

The only way to go in regards of a sane coding system for text files is utf-8.
It has to be the the default when ever possible. This provides maximal
portability and readability across operation systems and applications.
Also the Unix way of adding a new line into a text file has to be the
default. DOS uses carriage return and line feed ("\r\n") as a line ending, where
Unix uses just line feed ("\n").

#+BEGIN_SRC emacs-lisp
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8-unix)
(setq-default buffer-file-coding-system 'utf-8-unix)
(set-charset-priority 'unicode)
(setq default-process-coding-system '(utf-8-unix . utf-8-unix))
(setq locale-coding-system 'utf-8)
#+END_SRC

* Answer Questions Quicker

Emacs sometimes requires answering a yes-or-no question in order to make the
user aware of probably dangerous changes or decisions.
Simply pressing =y= for a positive or =n= for a negative response is way more
convenient compared to spelling out the whole words =yes= or =no=.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

* Highlight Current Line in Buffer

To make orientation within the buffer easy, the current line on which point is
gets highlighted.

#+BEGIN_SRC emacs-lisp
(global-hl-line-mode t)
#+END_SRC

* Use Ibuffer to Edit the Buffer List

By default =C-x C-b= calls the Buffer List. Ibuffer is an alternative with more
functionality when it comes to manipulate the buffer list and switching
buffers.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC

* Provide and Manage Packages
** =package.el=

Most extensions to Emacs can be loaded from archives, which are accessible via
Emacs' very own package manager =package.el=. To use this feature, =package.el=
needs to know, which archives it should use.
Out of the box, Emacs includes the =GNU ELPA= archive. It contains packages
conform with the terms of the Free Software Foundation.
For using the Org mode contribution files (some extra packages not included in
the Org mode version shipped with Emacs) and installing them via =package.el=,
the =Org ELPA= archive is added.
=MELPA= is an archive containing a lot of packages from the Open Source
community, which is the source for a lot of packages used in Cortex.
To make shure all packages mentioned in Cortex are loaded at Emacs startup, the
init file has to call the function =package-initialize=. This is necessary,
because some code blocks within Cortex depend on a packages installed by
=package.el=.

#+BEGIN_SRC emacs-lisp
(package-initialize)
(add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/") t)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
#+END_SRC

The command =M-x list-packages= brings up the package menu buffer, which lists
all packages available from the archives defined above. The command retrieves
the list of packages from the archive servers, if it has a connection to the
internet. Else it uses the most recently retrieved list.

Here are some of the frequently used commands in the package menu buffer:

| Key     | Command                      | Description                                                                                                                                                |
|---------+------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------|
| h       | (package-menu-quick-help)    | Summary of commands in the package menu buffer                                                                                                             |
| r       | (package-menu-refresh)       | Refresh package list                                                                                                                                       |
| i       | (package-menu-mark-install)  | Mark the package on the current line for installation (adds an ‘I’ character to the start of the line)                                                     |
| d       | (package-menu-mark-delete)   | Mark the package on the current line for deletion (adds a ‘D’ character to the start of the line                                                           |
| u <RET> |                              | Remove any installation or deletion mark previously added to the current line                                                                              |
| U       | (package-menu-mark-upgrades) | Mark all package with a newer available version for upgrading.  This places an ‘I’ on the new available versions, and a ‘D’ on the old installed versions. |
| x       | (package-menu-execute)       | Download and install all packages marked with ‘I’, and their dependencies; also, delete all packages marked with ‘D’                                       |

The command =(package-install PKG)= can be used to install package "PKG"
manually from a code block within Cortex.

** =use-package=

Most Emacs configurations out there tend to be quite extensive. I expect nothing
else for Cortex. Over time, it will grow and become cluttered. Loading time will
most likely go up linked to the size of packages used.
Having more control over when things get loaded or when certain code is executed
is very welcome.
The macro =use-package= provides this control. It isolates packages
configuration in an Emacs config so that code belonging to a certain package
only is executed when the package is loaded. When a package is loaded it is also
configurable. This has the potential to squeeze some performance out of Cortex
and to make Cortex clean, tidy and organized.
=use-package= obviously can't be installed by using its own macro. It needs to
be installed by the commands from =package.el=. Following the idea of using
=use-package= for every package within Cortex, this should be the only time a
package is installed without the =use-package= macro.

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
#+END_SRC

Some defaults are changed before =use-package= is loaded.
In order to make better use of the help commands, hooks are written using their
full name, when using the =:hook= option of =use-package= (after-init ==>
after-init-hook).

#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (setq use-package-hook-name-suffix nil))
(eval-when-compile
  (require 'use-package))
#+END_SRC

=use-package= provides several keywords to load and configure a package.
See a basic example below.

#+BEGIN_EXAMPLE emacs-lisp
(use-package foo
  :ensure t
  :init
  (setq foo-variable t)
  :config
  (foo-mode 1))
#+END_EXAMPLE

The macro starts with =use-package foo=, which will load the package =foo=, but
only, if it's already available on the system (else, a warning gets logged).

=:ensure t= makes sure, that the package is installed and will download it from
the package archives, if it's not present on the system. This is how packages
are fetched and installed in Cortex.

The =:init= keyword executes code before a package is loaded. It accepts one
or more forms, up to the next keyword. 

Similarly, =:config= can be used to execute code after a package is loaded.

* Themes

| [2020-11-03] | Initial setup |

The look of Emacs is defined in a theme. Custom themes usually alter e.g. the
colours used to highlight headings or code.
Readability and accessibility has highest priority. This may be to the expense
of having a "stylish" looking Emacs, but that's OK.

I found out about the =Modus= themes created by [[https://protesilaos.com][Protesilaos Stavrou]] while
watching one of his videos about Emacs. Those themes are conform with the
highest accessibility standard for colour contrast between background and
foreground values (WCAG AAA).

The themes will be shipped with Emacs starting version =28.1=. They are also
available from ELPA and Melpa archives. The version from Melpa is a
representation of the latest commit to the master branch of the themes repo and
should be the latest version available.

=Modus Operandi= is the light variant.
=Modus Vivendi= is the dark variant.

#+BEGIN_SRC emacs-lisp
(use-package modus-themes
  :ensure t
  :pin melpa)
#+END_SRC

The themes come with a lot of options for customization. If those are used, they
need to be set prior to the loading of the theme. It is very likely that
customizations should have effect on both variants of the theme. Therefore a
wrapper function can be used for customization and loading of the two themes.

A helper macro is needed to make this work.
=rrogg/format-sexp= will replace the symbolic expressions within =sexp= with
objects defined in =objects= and evaluate the resulting code.

#+BEGIN_SRC emacs-lisp
(use-package emacs
  :config
  (defmacro rrogg/format-sexp (sexp &rest objects)
    `(eval (read (format ,(format "%S" sexp) ,@objects)))))
#+END_SRC

The =rrogg/modus-theme-after-load-hook= can be used to run additional code
specifically after a theme has been loaded.

With the help of =rrogg/format-sexp= each of the two theme variants get a separate
function (=rrogg/modus-operandi= and =rrogg/modus-vivendi=) from a single source of
code. All customizations can be done here.

#+BEGIN_SRC emacs-lisp
(use-package emacs
  :config
  (defvar rrogg/modus-theme-after-load-hook nil
    "Hook that runs after loading a Modus theme.")

  (dolist (themes '("operandi" "vivendi"))
    (rrogg/format-sexp
     (defun rrogg/modus-%1$s ()
       (setq modus-%1$s-theme-org-blocks nil)
       (setq modus-%1$s-theme-scale-headings nil)
       (load-theme 'modus-%1$s t)
       (run-hooks 'rrogg/modus-theme-after-load-hook))
     themes)))
#+END_SRC

The light theme is the default.
I like to toggle between the variants manually for now.
There are options to switch between the variants atomatically by referencing
sunset and sundown, which might be explored further in the future.

#+BEGIN_SRC emacs-lisp
(use-package emacs
  :config
  (defun rrogg/themes-toggle ()
    "Toggle between light theme (`rrogg/modus-operandi') and dark theme (`rrogg/modus-vivendi')."
    (interactive)
    (if (eq (car custom-enabled-themes) 'modus-operandi)
        (progn
          (disable-theme 'modus-operandi)
          (rrogg/modus-vivendi))
      (disable-theme 'modus-vivendi)
      (rrogg/modus-operandi)))
  :hook (after-init-hook . rrogg/modus-vivendi)
  :bind ("<f5>" . rrogg/themes-toggle))
#+END_SRC

* Fonts

Typefaces (e.g. Inter) and fonts (e.g. Inter Extra Light 12) can be defined by
=set-face-attribute=. There are three faces: =default=, =fixed-pitch=
(monospaced) and =variable-pitch= (proportionally spaced). =fixed-pitch= is used
in programming modes. Sometimes reading prose or non-code texts is easier when
displayed in a =variable-pitch=.

For now, I'll start with my font choices from earlier configurations. Those are
=Hack= as monospaced font and =Inter= as proportionally spaced font.

#+BEGIN_SRC emacs-lisp
(use-package emacs
  :config
  (set-face-attribute 'default nil :family "Hack" :height 120)
  (set-face-attribute 'fixed-pitch nil :family "Hack" :height 120)
  (set-face-attribute 'variable-pitch nil :family "Inter" :height 120))
#+END_SRC

** Linux

=Hack= and =Inter= can be installed via =pacman=.

#+BEGIN_EXAMPLE
sudo pacman -S ttf-hack inter-font
#+END_EXAMPLE

Fonts will be installed to:

- =~/.local/share/fonts=  #if installed per user, without =sudo=
- =/usr/share/fonts=

** Windows

=Hack= can be installed via chocolatey.

#+BEGIN_EXAMPLE
chocolatey install hackfont
#+END_EXAMPLE

=Inter= needs to be downloaded from the [[https://rsms.me/inter/][website]] and installed manually according
to the included install instructions.

* no-littering - Keep .emacs.d Clean

| [2020-10-20] | Initial setup |

#+BEGIN_SRC emacs-lisp
(use-package no-littering
  :ensure t)
(require 'no-littering)
#+END_SRC

* Logging

Because Cortex is likely used on multiple hosts, each of those requires
host-specific logging. This will make it easier to compare versions of Emacs and
its packages. The following code is heavily inspired by a [[https://github.com/novoid/dot-emacs/blob/master/config.org#host-specific-log-file-my-log-hostspecific][section in Karl Voit's
dot-emacs]].

A folder for all sorts of logs is defined in =rrogg/cortex-var-log-directory=. If
this folder is not existing, it gets created.
The log file is defined in =rrogg/cortex-var-log-hostname-file= and consists of the
hostname of the system.

#+BEGIN_SRC emacs-lisp
(setq rrogg/cortex-var-log-directory (concat no-littering-var-directory "log/"))
(when (not (file-exists-p rrogg/cortex-var-log-directory))
  (make-directory rrogg/cortex-var-log-directory))
(setq rrogg/cortex-var-log-hostname-file (concat rrogg/cortex-var-log-directory "host-" system-name ".txt"))
#+END_SRC

The content of the host-specific log is similar to the following:

#+BEGIN_EXAMPLE
Started on 2020-10-20T22:09:44
emacs-version 27.1
org-version 9.1.6
magit-version 2.10.3
#+END_EXAMPLE

At startup of Emacs the host-specific log file is overwritten wit the current time.

#+BEGIN_SRC emacs-lisp
(write-region (concat "Started on " rrogg/cortex-start-time-iso "\n") nil rrogg/cortex-var-log-hostname-file)
#+END_SRC

Using the function =rrogg/cortex-log-hostspecific=, will append a string,
e.g. emacs-version, and a command, e.g. =emacs-version=, to the log file.

#+BEGIN_SRC emacs-lisp
(defun rrogg/cortex-log-hostspecific (string command)
  "append a string and the result of a command to the rrogg/cortex-var-log-hostname-file file"
  (interactive)
  (write-region (concat string " " command "\n") nil rrogg/cortex-var-log-hostname-file t))
#+END_SRC

This is the first use of the function above. Write the Emacs version to the log
file.

#+BEGIN_SRC emacs-lisp
(rrogg/cortex-log-hostspecific "emacs-version" emacs-version)
#+END_SRC

* Check for Binaries

Some functionality in Cortex depends on external binaries.
Receiving feedback if those are present on the system is valuable for
debugging.
The function =rrogg/binary-found= returns the path for a given binary.

#+BEGIN_SRC emacs-lisp
(defun rrogg/binary-found(binaryname)
  "Returns the path where a binary executable can be found."
  (locate-file binaryname exec-path exec-suffixes 1))
#+END_SRC

This can be used to generate a report like below:

#+BEGIN_EXAMPLE
git binary: /usr/bin/git
aspell binary: /usr/bin/aspell
gnuplot binary:
#+END_EXAMPLE

The function =rrogg/eval-if-binary-or-warn= checks for a given binary and writes
the binary name into the list =rrogg/binary-not-found-list=.
The list is displayed in the =*Messages*= buffer after Cortex has been loaded.

#+BEGIN_SRC emacs-lisp
(defvar rrogg/binary-not-found-list nil
  "Holds a list of binaries which could not be found via rrogg/eval-if-binary-or-warn()")
(defun rrogg/eval-if-binary-or-warn (binaryname &optional warningtext)
  "Checks if a binary can be found in the path via rrogg/binary-found().

  If not found, a warning message is printed, which can be defined as an optional parameter as well.
  Additionally, the not found binaries are collected in the variable rrogg/binary-not-found-list."
  (or warningtext (setq warningtext (concat "»»» I could not locate the PATH-binary for: " binaryname)))
  (let* ((binarypath (rrogg/binary-found binaryname)))
    (if binarypath
        ;; binary was found in exec-path
        (concat binarypath)
      (progn
        ;; binary NOT found in exec-path:
        (message warningtext)
        (if rrogg/binary-not-found-list
            (add-to-list 'rrogg/binary-not-found-list binaryname)
          (setq rrogg/binary-not-found-list (list binaryname)))))))
#+END_SRC

=rrogg/eval-if-binary-or-warn= is also used to evaluate if a functionality of
Cortex should be configured or not. See the example below:

#+BEGIN_EXAMPLE
(when (rrogg/eval-if-binary-or-warn "git")
  (use-package magit
    :ensure t))
#+END_EXAMPLE

* Redirect Backups and Auto-Saves

Emacs creates backups of every file currently opened and containing changes.
The filenames of those backups end with a tilde (=foo.bar~=). After some time
this feature messes uo folders very much. One can keep a clear view by
redirecting those backups to a central place where they can be accessed if
needed. Backups will be created for every file, even if they are version
controlled with git.
Auto-saves occurs if a file hasn’t been saved since a certain time
(=auto-save-timeout=) or a certain amount of typed characters
(=auto-save-interval=).
Files generated by auto-save have a leading and trailing ‘#’, eg. the auto-save
file for foo.bar is #foo.bar#. Auto-save files can be recovered with =M-x
recover-file <RET> file <RET>=.

#+BEGIN_SRC emacs-lisp
(setq auto-save-file-name-transforms
      `((".*" , (no-littering-expand-var-file-name "auto-save/") t)))
(setq vc-make-backup-files t)
#+END_SRC

* Magit - Using git Within Emacs

| [2020-10-20] | Initial setup        |
| [2021-01-14] | Tweaked commit setup |

=magit= is a superb interface to =git=.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :if (rrogg/eval-if-binary-or-warn "git")
  :ensure t)
#+END_SRC

** How to Write a Good Commit Message

A good commit message follows [[https://chris.beams.io/posts/git-commit/][7 rules]]:

1. Separate subject from body with a blank line
2. Limit the subject line to 50 characters
3. Capitalize the subject line
4. Do not end the subject line with a period
5. Use the imperative mood in the subject line
6. Wrap the body at 72 characters
7. Use the body to explain what and why vs. how

For example:

#+BEGIN_EXAMPLE
Summarize changes in around 50 characters or less

More detailed explanatory text, if necessary. Wrap it to about 72
characters or so. In some contexts, the first line is treated as the
subject of the commit and the rest of the text as the body. The
blank line separating the summary from the body is critical (unless
you omit the body entirely); various tools like `log`, `shortlog`
and `rebase` can get confused if you run the two together.

Explain the problem that this commit is solving. Focus on why you
are making this change as opposed to how (the code explains that).
Are there side effects or other unintuitive consequences of this
change? Here's the place to explain them.

Further paragraphs come after blank lines.

 - Bullet points are okay, too

 - Typically a hyphen or asterisk is used for the bullet, preceded
   by a single space, with blank lines in between, but conventions
   vary here

If you use an issue tracker, put references to them at the bottom,
like this:

Resolves: #123
See also: #456, #789
#+END_EXAMPLE

All stylistic rules can be taken care of by =magit=.
It will color characters on the summary line exceeding length of 50 red and does
the same for the second line, which should be blank.
The body of the message is wrapped at length 72.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :if (rrogg/eval-if-binary-or-warn "git")
  :config
  (setq git-commit-summary-max-length 50)
  (setq git-commit-fill-column 72)
  (defun rrogg/git-commit-setup()
    (insert "#1. Capitalize the subject line
#2. Do not end the subject line with a period
#3. Use the present tense imperative mood in the subject line and body
#4. Use the body to explain what and why vs. how
#-----------------------------------------------
#If applied, this commit will …
"))
  :hook (git-commit-setup-hook . rrogg/git-commit-setup))
#+END_SRC

* Maximize Frame Window

The Emacs frame is maximized at all times to make use of every pixel on the
screen.

#+BEGIN_SRC emacs-lisp
(toggle-frame-maximized)
#+END_SRC

* Delimiters and Parentheses
:PROPERTIES:
:ID:       6eb9c2a0-2d30-444d-a7a7-08fc84ddcd0e
:END:

=show-paren-mode= highlights matching parentheses, which play a very important
role when writing code in emacs lisp.

#+BEGIN_SRC emacs-lisp
(use-package paren
  :config
  (setq show-paren-style 'parenthesis)
  :hook (after-init-hook . show-paren-mode))
#+END_SRC

* Tabs and Indentation
:PROPERTIES:
:ID:       556b6efd-823a-4d33-927b-3ddf948c6eea
:END:

Tabs are disabled.
The =TAB= key will first try to indent the line and then try to complete what is
at point (if it can be completed).

#+BEGIN_SRC emacs-lisp
(use-package emacs
  :config
  (setq-default tab-always-indent 'complete)
  (setq-default tab-width 4)
  (setq-default indent-tabs-mode nil))
#+END_SRC

* Save Commands Across Sessions

Emacs doesn't have a persistent command history by default. The build-in history
gets resetted with every new Emacs session. The package =savehist= implements a
session independent history.

#+BEGIN_SRC emacs-lisp
(use-package savehist
  :config
  (setq savehist-file (concat no-littering-var-directory "savehist"))
  (setq savehist-save-minibuffer-history t)
  (setq history-length 1000)
  (setq history-delete-duplicates t)
  :hook (after-init-hook . savehist-mode))
#+END_SRC

* Auto Revert Mode

Ensures that (external) changes to the content of a file are updated in the
buffer of that file.

#+BEGIN_SRC emacs-lisp
(use-package autorevert
  :config
  (setq auto-revert-verbose t)
  :hook (after-init-hook . global-auto-revert-mode))
#+END_SRC

* Completion
** Orderless Completion Style
:PROPERTIES:
:ID:       51901de4-e349-4de2-9b5e-0be7da29f1ef
:END:

| [2020-12-10] | Initial setup |

The orderless completion style allows selecting candidates using strings that
appear somewhere in it. This allows to select the file =example -- tag.org= by
typing =tag= in the minibuffer. If there are multiple candidates left, =tag ex=
will select the file I want. This is helpful if I'm not completely sure what the
candidate is named exactly.


#+BEGIN_SRC emacs-lisp
(use-package orderless
  :ensure t)
#+END_SRC

** Minibuffer
This section configures the the minibuffer and how completion will be done when
in it.

Use the [[id:51901de4-e349-4de2-9b5e-0be7da29f1ef][orderless]] and partial completion styles.

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref completion-style
(setq completion-styles '(orderless partial-completion))
#+END_SRC

Completions in the minibuffer ignore case of candidates.

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref completion-ignore-case
(setq completion-ignore-case t)
(setq read-file-name-completion-ignore-case t)
(setq read-buffer-completion-ignore-case t)
#+END_SRC

Display completions sorted vertically in columns (in alphabetical order) in the
*Completions* buffer.

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref completion-buffer-format
(setq completions-format 'vertical)
#+END_SRC

#+BEGIN_SRC emacs-lisp :noweb yes
(use-package minibuffer
  :config
  <<completion-style>>
  <<completion-ignore-case>>
  <<completion-buffer-format>>)
#+END_SRC

** Visualisation of Completion Candidates - Icomplete

Let the built-in =Icomplete= handle the visualisation of completion candidates.

#+BEGIN_SRC emacs-lisp
(use-package icomplete
  :config
  (icomplete-mode t))
#+END_SRC

* PDF

Rendering PDF documents inside of Emacs enables a direct comparison of the
source material of an export and the result of the export done by Emacs (or more
specifically Org mode).
The package =pdf-tools= comes with many advantages over the built in docview.
It is based on the poppler package for Linux which will be installed by the
Emacs-package from the following source block.
The PDF document is scaled to fit the buffer it will be displayed in. Adjusting
the scaling can easily be done via =-= and =+=.

#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :ensure t
  :config
  (pdf-tools-install)
  (setq-default pdf-view-display-size 'fit-page))
#+END_SRC

** Tmp Directories

Directories for temporarily storing data for processing.

#+BEGIN_SRC emacs-lisp
(setq rrogg/tmp-tools-directory "~/tmp/tools/")
(setq rrogg/tmp-pdf-split-directory (expand-file-name (concat rrogg/tmp-tools-directory "pdfseparate/")))
#+END_SRC

** Selected Pages

Select pages from a PDF.

#+BEGIN_SRC emacs-lisp
(defvar-local rrogg/pdf-selected-pages '())

(defun rrogg/pdf-select-page ()
  "Add current page to list of selected pages."
  (interactive)
  (add-to-list 'rrogg/pdf-selected-pages (pdf-view-current-page) t)
  (setq rrogg/pdf-selected-pages (sort rrogg/pdf-selected-pages #'<)))
#+END_SRC

** All Pages

Find out how many pages a document has and build a list with one entry for each
page.

#+BEGIN_SRC emacs-lisp
(defun rrogg/pdf-get-all-pages-list ()
  "Get a list of all pages of current PDF."
  (number-sequence 1 (pdf-cache-number-of-pages)))
#+END_SRC

** Prepare List

*** Delete Selection List

Remove all selected pages from the list of all pages.

#+BEGIN_SRC emacs-lisp
(defun rrogg/pdf-remaining-pages-list (seq1 seq2)
  "Build a list of all pages of current PDF that remain in output PDF."
  (seq-difference seq1 seq2))
#+END_SRC

*** Expand List

Replace each page (number) in the list with the complete path to the PDF of that
page within the tmp directory.

#+BEGIN_SRC emacs-lisp
(defun rrogg/build-list (seq)
  "."
  (--map
   (concat
    rrogg/tmp-pdf-split-directory
    (file-name-base buffer-file-name)
    "-"
    it
    ".pdf")
   (mapcar
    'number-to-string
    seq)))
#+END_SRC

*** Process List

Add the output file name to the end of the list of input files.
The resulting list has all input arguments for the PDF processing.

#+BEGIN_SRC emacs-lisp
(defvar-local rrogg/pdf-merge-args '())

(defun rrogg/pdf-append-output-file (inputlist)
  "."
  (add-to-list
   'inputlist
   (expand-file-name (read-file-name "Save selection as: ")) t))
#+END_SRC

** Process Pages

*** Split

Split the PDF in the current buffer into one PDF per page.
Use the tmp directory to store these files.

#+BEGIN_SRC emacs-lisp
(defun rrogg/pdf-split ()
  "."
  (start-process
   "pdfseparate"
   "*pdf-processing*"
   "pdfseparate"
   (buffer-file-name)
   (concat
    rrogg/tmp-pdf-split-directory
    (file-name-base buffer-file-name)
    "-%d.pdf")))
#+END_SRC

*** Merge

Combine all PDFs specified in buffer local variable =rrogg/pdf-merge-args= into
a single PDF.

#+BEGIN_SRC emacs-lisp
(defun rrogg/pdf-merge ()
  "."
  (apply
   'start-process
   "pdfunite"
   "*pdf-processing*"
   "pdfunite"
   rrogg/pdf-merge-args))
#+END_SRC

*** Clean

Delete all tmp files.

#+BEGIN_SRC emacs-lisp
(defun rrogg/clean-up ()
  "."
  (dolist (x (rrogg/build-list (rrogg/pdf-get-all-pages-list)))
    (delete-file x)))
#+END_SRC

*** Full

Full function for extracting selected PDF pages into a single PDF.

#+BEGIN_SRC emacs-lisp
(defun rrogg/pdf-extract-selected-pages ()
  "."
  (interactive)
  (setq rrogg/pdf-merge-args (rrogg/pdf-append-output-file
                              (rrogg/build-list rrogg/pdf-selected-pages)))
  (set-process-sentinel
   (rrogg/pdf-split)
   (lambda (process event) (when (= 0 (process-exit-status process))
                             (set-process-sentinel
                              (rrogg/pdf-merge)
                              (lambda (process event) (when (= 0 (process-exit-status process))
                                                         (rrogg/clean-up))))))))
#+END_SRC

Full function for deleting selected PDFs from the source PDF. The resulting PDF
can also be saved in another files.

#+BEGIN_SRC emacs-lisp
(defun rrogg/pdf-delete-selected-pages ()
  "."
  (interactive)
  (setq rrogg/pdf-merge-args (rrogg/pdf-append-output-file
                              (rrogg/build-list
                               (rrogg/pdf-remaining-pages-list (rrogg/pdf-get-all-pages-list) rrogg/pdf-selected-pages))))
  (set-process-sentinel
   (rrogg/pdf-split)
   (lambda (process event) (when (= 0 (process-exit-status process))
                             (set-process-sentinel
                              (rrogg/pdf-merge)
                              (lambda (process event) (when (= 0 (process-exit-status process))
                                                         (rrogg/clean-up))))))))
#+END_SRC

* eBooks

| [2021-10-05] | Initial setup |

Emacs can't render the epub format out of the box.
A package called =nov.el= can do that.

#+BEGIN_SRC emacs-lisp
(use-package nov
  :ensure t)
(add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
#+END_SRC

* Calendar

The agenda is also used as a calendar.

** General

When prompting for a date, e.g. when scheduling a task, the Emacs calendar is
used to give an overview of the last, current and upcoming month.
The week column shows Sunday as first day of the week by default, while Monday
is what I want.

#+BEGIN_SRC emacs-lisp
(use-package calendar
  :init
  (setq calendar-week-start-day 1))
#+END_SRC

** German Holidays

Information about German holidays are featured in the calendar, making it easy
to spot when Easter will be next year.

The list =calendar-holidays= contains all days of the year which I don't have be
at work. To make them show up in the agenda, the line =%%(org-calendar-holiday)=
has to appear somewhere below a heading in an org file included in the
=org-agenda-files=.

#+BEGIN_SRC emacs-lisp
(use-package holidays
  :init
  (setq calendar-holidays
        '((holiday-fixed 1 1 "Neujahr")
          (holiday-fixed 5 1 "Tag der Arbeit")
          (holiday-fixed 10 3 "Tag der Deutschen Einheit")
          (holiday-fixed 12 25 "1. Weihnachtstag")
          (holiday-fixed 12 26 "2. Weihnachtstag")
          (holiday-easter-etc  -2 "Karfreitag")
          (holiday-easter-etc  +1 "Ostermontag")
          (holiday-easter-etc +39 "Christi Himmelfahrt")
          (holiday-easter-etc +50 "Pfingstmontag")
          (holiday-easter-etc +60 "Fronleichnam")
          (holiday-fixed 11 1 "Allerheiligen"))))
#+END_SRC

** Special Dates

There are also days during the year connected to a event or special
meaning. Those days are featured in the agenda but I usually have to appear at
work that day. Therefore they should be treated a little different from actual
holidays.

Org mode (specifically =holidays.el=) supports only one list of dates to be
shown in the agenda by default (dates defined in =calendar-holidays=).
By copying and editing the three functions below, it is possible to include a
second list for special days which are not holidays in Germany.

To make them show up in the agenda, the line =%%(rrog:org-calendar-specialdate)=
has to appear somewhere in an org file included in the =org-agenda-files=.

#+BEGIN_SRC emacs-lisp
(defun rrogg/org-calendar-specialdate ()
  "List of special dates, for Diary display in Org mode."
  (require 'holidays)
  (let ((hl (rrogg/calendar-check-specialdates org-agenda-current-date)))
    (and hl (mapconcat #'identity hl "; "))))

(defun rrogg/calendar-check-specialdates (date)
  "Check the list of special dates for any that occur on DATE.
DATE is a list (month day year).  This function considers the
special dates from the list `calendar-specialdates', and returns a list of
strings describing those special dates that apply on DATE, or nil if none do."
  (let ((displayed-month (calendar-extract-month date))
        (displayed-year (calendar-extract-year date))
        specialdate-list)
    (dolist (h (rrogg/calendar-specialdate-list) specialdate-list)
      (if (calendar-date-equal date (car h))
          (setq specialdate-list (append specialdate-list (cdr h)))))))

(defun rrogg/calendar-specialdate-list ()
  "Form the list of special dates that occur on dates in the calendar window.
The special dates are those in the list `calendar-specialdates'."
  (let (res h err)
    (sort
     (dolist (p rrogg/calendar-specialdates res)
       (if (setq h (if calendar-debug-sexp
                       (let ((debug-on-error t))
                         (eval p))
                     (condition-case err
                         (eval p)
                       (error
                        (display-warning
                         'specialdays
                         (format "Bad specialdate list item: %s\nError: %s\n"
                                 p err)
                         :error)
                        nil))))
           (setq res (append h res))))
     'calendar-date-compare)))

(setq rrogg/calendar-specialdates
      '((holiday-float 5 0 2 "Muttertag")
        (holiday-float 6 0 3 "Vatertag")
        (holiday-float 12 0 -4 "1. Advent" 24)
        (holiday-float 12 0 -3 "2. Advent" 24)
        (holiday-float 12 0 -2 "3. Advent" 24)
        (holiday-float 12 0 -1 "4. Advent" 24)
        (holiday-fixed 12 24 "Heiligabend")
        (holiday-fixed 1 6 "Heilige Drei Könige")
        (holiday-easter-etc -52 "Weiberfastnacht")
        (holiday-easter-etc -50 "Karnevalssamstag")
        (holiday-easter-etc -49 "Karnevalssonntag")
        (holiday-easter-etc -48 "Rosenmontag")
        (holiday-easter-etc -47 "Veilchendienstag")
        (holiday-easter-etc -46 "Aschermittwoch")
        (holiday-easter-etc -3 "Gründonnerstag")
        (holiday-easter-etc   0 "Ostersonntag")
        (holiday-easter-etc +49 "Pfingstsonntag")
        (holiday-fixed 8 15 "Mariae Himmelfahrt")
        (holiday-fixed 11 11 "Martinstag")
        (holiday-fixed 11 11 "Elfter im Elften")
        (holiday-float 11 3 1 "Buss- und Bettag" 16)
        (holiday-float 11 0 1 "Totensonntag" 20)))
#+END_SRC

** Solar Calendar

Emacs can calculate the time of sunrise, sundown and also other events based on
the position of the sun. In order to ensure that this calculations are correct,
latitude, longitude and location name need to be adjusted to the current
position on earth.

#+BEGIN_SRC emacs-lisp
(use-package solar
  :config
  (setq calendar-latitude [51 14 north])
  (setq calendar-longitude [6 47 east])
  (setq calendar-location-name "Düsseldorf, NRW"))
#+END_SRC

Those solar events shall be categorized independently from other calendar
entries. This gives free choice on if and how this gets integrated into the
agenda.

Similar to the special dates solar dates show up in the agenda by including the
line =%%(rrogg/org-calendar-solar)= somewhere in one of the =org-agenda-files=.

#+BEGIN_SRC emacs-lisp
(defun rrogg/org-calendar-solar ()
  "List of solar dates, for Diary display in Org mode."
  (require 'holidays)
  (let ((hl (rrogg/calendar-check-solar org-agenda-current-date)))
    (and hl (mapconcat #'identity hl "; "))))

(defun rrogg/calendar-check-solar (date)
  "Check the list of solar for any that occur on DATE.
DATE is a list (month day year).  This function considers the
special dates from the list `calendar-solar', and returns a list of
strings describing those solar that apply on DATE, or nil if none do."
  (let ((displayed-month (calendar-extract-month date))
        (displayed-year (calendar-extract-year date))
        solar-list)
    (dolist (h (rrogg/calendar-solar-list) solar-list)
      (if (calendar-date-equal date (car h))
          (setq solar-list (append solar-list (cdr h)))))))

(defun rrogg/calendar-solar-list ()
  "Form the list of solar that occur on dates in the calendar window.
The solar are those in the list `calendar-solar'."
  (let (res h err)
    (sort
     (dolist (p rrogg/calendar-solar res)
       (if (setq h (if calendar-debug-sexp
                       (let ((debug-on-error t))
                         (eval p))
                     (condition-case err
                         (eval p)
                       (error
                        (display-warning
                         'solar
                         (format "Bad solar list item: %s\nError: %s\n"
                                 p err)
                         :error)
                        nil))))
           (setq res (append h res))))
     'calendar-date-compare)))

(setq rrogg/calendar-solar
      '((holiday-sexp calendar-daylight-savings-starts
	                  (format "Beginn der Sommerzeit – die Uhr wird um eine Stunde vorgestellt %s"
		                      (solar-time-string
			                   (/ calendar-daylight-savings-starts-time . #1=((float 60)))
			                   calendar-standard-time-zone-name)))
        (holiday-sexp calendar-daylight-savings-ends
	                  (format "Ende der Sommerzeit – die Uhr wird um eine Stunde zurückgestellt %s"
		                      (solar-time-string
			                   (/ calendar-daylight-savings-ends-time . #1#)
			                   calendar-daylight-time-zone-name)))))
#+END_SRC

* Org Mode

Org mode is right at the core of Cortex. It's the glue which connects task
management, literate programming, contact managment, dealing with mail,
composing and exporting text and many more things.

** General Settings

All files of type =.org= or =.org_archive= are automatically opened with Org
mode activated within Emacs.
A lot of helpful packages are contributed to the Org mode source. To ensure that
they are installed by Cortex, Org mode is retrieved from the =orgmode.org/elpa=
repository.
The indicator for a collapsed heading with an existing body of text
(=org-ellipsis=) is changed to =" ⤵"= , which is a more unique and intuitiv then
the standard ="..."=.

#+BEGIN_SRC emacs-lisp
(use-package org
  :mode (("\\.\\(org\\|org_archive\\)$" . org-mode))
  :ensure org-plus-contrib
  :config
  (defvar rrogg/org-config-start-time (current-time) "Time when my org-mode config was started")
  (message "★→ Org mode")
  (rrogg/cortex-log-hostspecific "org-version" org-version)
  (setq org-ellipsis " ⤵"))
#+END_SRC

Indentation of text below a heading up to the last star (=*=) of the heading is
enabled. All leading stars are hidden.
This can be turned off on a per file basis by putting =#+STARTUP: noindent= at
the start of the file.
Only major headings are shown as folded on startup.
Start a new line after a heading at the beginning of the line, no indentation.

#+BEGIN_SRC emacs-lisp
(use-package org
  :config
  (setq org-startup-indented t)
  (setq org-startup-folded t)
  (setq org-adapt-indentation nil))
#+END_SRC

** Clearly Identifiable Org Headings

In order to make a link to an org heading independent from the location of that
heading, =org-id= takes care of creating an unique identifier for a heading, if
a link to it gets stored (=org-store-link=) and there is no ID present for it.
Having point anywhere on the body of an org heading, invoking =C-c l= will do
the above. =C-c C-l= can be invoked to insert a link to an org entry.

There is an issue with an niche case: If =org-store-link= is called from a
fresh Emacs session, it won't create an =:ID:= property when point is on a
heading without one. Invoking =(featurep 'org-id)= returns nil, so org-id is not
started. This might be caused by =use-package=. The =org-id= module is only
loaded if one of its commands is called. =org-store-link= only checks if
=org-id-link-to-org-use-id= is non-nil, but it won't see it because it has not
been loaded yet. One could solve this issue by adding a =(require 'org-id)= to
the source block below. This is annoying, so I'll go with the ugly fix.

When point is on a link, =RET= will follow it.

#+BEGIN_SRC emacs-lisp
(use-package org
  :config
  (require 'org-id)
  (setq org-id-method 'uuid)
  (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)
  (setq org-return-follows-link t)
  :bind ("C-c l" . org-store-link))
#+END_SRC

** Tasks and States
:PROPERTIES:
:ID:       513bdaa7-0272-4202-b277-51ac65d1b236
:END:

#+BEGIN_SRC emacs-lisp
(use-package org
  :config
  (setq org-todo-keywords
        '((sequence "NEXT(n)" "WAITING(w)" "CALL(c)" "VISIT(v)" "TRAVEL(t)" "PLANNING(p)" "STARTED(s)" "HOLD(h)" "|" "DONE(d)" "CANCELLED(C)" "NOPART(N)")))
  (setq org-use-fast-todo-selection t)
  (setq org-treat-S-cursor-todo-selection-as-state-change nil))
#+END_SRC

*** Tasks

A task is the basic form of a thing that can be done.
It can have unique states which are covered below:

- =NEXT= tasks are things that I can work on right now; they are not blocked by anything and can be
  picked up right away.
- =WAITING= tasks are things that are waiting on the completion of other tasks,
  be it my own or external.
- =DONE= tasks that are complete and ready for archiving.
- =CANCELLED= tasks are aborted and won't be completed.

*** Projects

A grouping of tasks towards a certain goal is a project; write an Emacs
configuration, raise a family, build a new shelve for the basement.
The heading under which all those tasks can be grouped, is representative for
the project and can have following states:

- =PLANNING= A project that is still brainstormed, not fully flashed
  out. Sometimes it exists only in the form of a few ideas. No actual work has
  been done in order to progress towards a goal.
- =STARTED= Projects that have been worked on.
- =HOLD= Projects that are on hold.
- =DONE= Projects that reached the defined goal. There might be projects which
  naturally can't reach that state.
- =CANCELLED= Projects that are abandoned and won't be completed.

*** Calls

I collect phone calls and conference calls ("meetings") under this
keyword. Calls can be spontaneous or scheduled.

- =CALL= Calls that are scheduled or happened adhoc.
- =DONE= Calls that happened and I participated in.
- =CANCELLED= Cancelled calls that are not moved.
- =NOPART= Calls that I did not participate in.

*** Visits

Physical meetings are assigned with this keyword. A visit usually requires me to
change my location, because they are not virtual meetings. Visits can also be
events like concerts, trade shows. Visits have the same states as the very
similar keyword calls.

- =VISIT= Visits that are scheduled.
- =DONE= Visits that happened and I participated in.
- =CANCELLED= Cancelled visits that are not moved.
- =NOPART= Visits that I did not participate in.

*** Travels

Traveling from one place to another by bike, car, train, plane, boat or even by
walking is marked with this keyword.

- =TRAVEL= A block of time for getting from A to B.
- =DONE= That trip has been completed.
- =CANCELLED= The trip has been cancelled.

** Capture New Items

Getting information into Org mode has to be fast and easy. A convenient way to
create items is to use =org-capture=.
Called by pressing =C-c c=, =org-capture= shows a menu from which a template
specifically tailored to the information to be entered can be selected.
Selecting a single destination for those captured items is sometimes quite hard,
especially for tasks, which can belong to different contexts like projects, work
related things or private activities. Choosing the final destination for a
captured item during the capture process most often slows the process down to
much. I want to get information out of my head into the system fast, so I can
move on and deal with other things. Therefore all captures shall be collected
at a single place by default. The items in there get refiled in another
process independent from the capture process. This place saved in the
=org-default-notes-file= variable, which points to my =refile.org= file.

#+BEGIN_SRC emacs-lisp
(use-package org
  :config
  (setq org-directory "~/org/")
  (setq org-default-refile-file (concat org-directory "refile.org"))
  (setq org-default-notes-file (concat org-directory "notes.org"))
  :bind ("C-c c" . org-capture))
#+END_SRC

*** Template: Tasks

The default task tracking template will stick the item into =refile= with the
=NEXT= state. The task state can be changed if that isn't accurate, but for most
things that are going to be captured it is fine using this.
A link to the headline from which =org-capture= was called from, is stored via
=%a=. If that heading doesn't have a ID yet, it is advised to call =C-c l=
(=org-store-link=) first. This will prevent fragile links by using =org-id=
based links.

#+BEGIN_SRC emacs-lisp
(setq rrogg/capture-template-task "* NEXT %?
:LOGBOOK:
:CREATED: %U
:END:
%a


")
#+END_SRC

*** Template: Calls

Calls have a active time stamp in their heading, which will be recognized by
=org-agenda=.

#+BEGIN_SRC emacs-lisp
(setq rrogg/capture-template-call "* CALL %(org-time-stamp nil) %?
:LOGBOOK:
:CREATED: %U
:END:


")
#+END_SRC

*** Template: Notes

Notes come in the form of ideas, small snippets of code with a short
documentation, bits of information worth to be remembered and
learnings. Combined, those can be reforged into an engineers workbook, serve as
basis for researching a given topic further and other things.
I still have to explore the direction I want to go with this. Something like a
Zettelkasten or a recreation of Roam Research seems very interesting. In the end
it all comes down to how quick information can be pulled out of the system.
For a start, this right here is about getting information into it.

#+BEGIN_SRC emacs-lisp
(setq rrogg/capture-template-note "* %?
:LOGBOOK:
:CREATED: %U
:END:


")
#+END_SRC

*** Template: Contacts

Essential contact information is first name, family name, birthday and e-mail
address. Birthday and e-mail address have to be treated specially, because those
properties break the org-agenda if not present or in the wrong format.

#+BEGIN_SRC emacs-lisp
(setq rrogg/capture-template-contact "* %(rrogg/capture-prompt \"First Name\" 'rrogg/firstname) %(rrogg/capture-prompt \"Family Name\" 'rrogg/familyname) :%(symbol-value 'rrogg/firstname)%(symbol-value 'rrogg/familyname):
:PROPERTIES:
:TYPE: %(rrogg/capture-selection \"Person or Company? \" '(\"person\" \"company\") 'rrogg/person-or-company)%(if (string= rrogg/person-or-company \"person\") (concat \"\n:GENDER: \" (rrogg/capture-selection \"Male or Female? \" '(\"male\" \"female\" \"transgender\") 'rrogg/gender)))
:NICKNAME:
:MIDDLENAME:
:BIRTHNAME:
:BIRTHDAY:%(if (y-or-n-p \"Birthday known? \") (concat \" \" (rrogg/capture-prompt-short-date \"Born:\" 'rrogg/birthday)) \":\") 
:MOBILE:
:HOMEPHONE:
:WORKMOBILE:
:WORKPHONE:
:EMAIL: %(if (y-or-n-p \"E-Mail known?\") (rrogg/capture-prompt \"E-Mail private\" 'rrogg/emailprivate) \"-\")
:WORKEMAIL:
:URL:
:STREET:
:POSTALCODE:
:CITY:
:REGION:
:COUNTRY:
:COMPANY:
:UNIT:
:TITLE:
:MANAGER:
:WORKSTREET:
:WORKPOSTALCODE:
:WORKCITY:
:WORKREGION:
:WORKCOUNTRY:
:PHOTOGRAPH: [[photo:%(symbol-value 'rrogg/firstname) %(symbol-value 'rrogg/familyname).jpg]]
:END:
:LOGBOOK:
:CREATED: %U
:END:

")
#+END_SRC

*** Functions for Capture Templates

#+BEGIN_SRC emacs-lisp
(defun rrogg/capture-prompt (prompt variable)
  "PROMPT for string, save it to VARIABLE and insert it."
  (make-local-variable variable)
  (set variable (read-string (concat prompt ": "))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun rrogg/capture-selection (prompt list variable)
  "Let the user choose between a pre-defined set of strings and save it to VARIABLE."
  (make-local-variable variable)
  (let ((selected-value (completing-read prompt list nil t)))
    (set variable selected-value)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun rrogg/capture-prompt-short-date (prompt variable)
  "PROMPT for a date, save it to VARIABLE and insert it as time stamp (YYYY-MM-DD)."
  (make-local-variable variable)
  (set variable
       (format-time-string
        "%Y-%m-%d"
        (org-read-date nil t nil prompt))))
#+END_SRC

*** Calling Capture Templates

The templates created earlier can be selected by invoking =C-c c= followed by
the letter designated for a certain template (e.g. =C-c c c= for capturing
contact information).
After the capture process is completed for an item, a unique ID is created and
attached to it.

#+BEGIN_SRC emacs-lisp
(use-package org
  :config
  (setq org-capture-templates `(("t" "Task" entry (file org-default-refile-file)
                                 ,rrogg/capture-template-task)
                                ("c" "Call" entry (file org-default-refile-file)
                                 ,rrogg/capture-template-call)
                                ("C" "Contact" entry (file org-default-refile-file)
                                 ,rrogg/capture-template-contact)
                                ("n" "Note" entry (file org-default-notes-file)
                                 ,rrogg/capture-template-note)))
 :hook (org-capture-prepare-finalize-hook . org-id-get-create))
#+END_SRC

** Organize Captured Items

All captured items get created in the =org-default-notes-file= and are refiled
from there.
Invoking =C-c C-w= starts the refile process. Possible targets are all
=org-agenda-files= with headings up to 9 levels deep.
The refile process is allowed to create parent tasks with confirmation.
A time stamp is created on completion of the refile process for an item and
logged into the item's logbook drawer.

#+BEGIN_SRC emacs-lisp
(use-package org
  :config
  (setq org-refile-targets '((nil :maxlevel . 9)
			                 (org-agenda-files :maxlevel . 9)
                             (org-contacts-files :maxlevel . 9)))
  (setq org-refile-use-outline-path 'file)
  (setq org-outline-path-complete-in-steps nil)
  (setq org-refile-allow-creating-parent-nodes '(confirm))
  (setq org-log-refile 'time)
  (setq org-log-into-drawer t))
#+END_SRC

** Contacts

=org-contacts= takes care of managing contact information of family, friends,
co-workers, business contacts, venues, stores etc.
All this information gets stored in one org file, which has to be known to
org-contacts.
In order to include birthdays of contacts to the agenda, this file
also has to be included in the =org-agenda-files=. Birthdays will show up, if
the following line appears somewhere in an agenda file:

#+BEGIN_EXAMPLE
%%(org-contacts-anniversaries)
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
(use-package org-contacts
  :config
  (setq org-contacts-files '("~/org/contacts.org")))
#+END_SRC

*** Functions for Contacts
**** Link to Contact Entry
:PROPERTIES:
:ID:       c1b86224-1483-47d1-9e40-fc269ea9b993
:END:

Calling the interactive function =rrogg/link-to-contact= will prompt for a
contact name and insert a link to that contact.

#+BEGIN_SRC emacs-lisp
(defun rrogg/link-to-contact ()
  "Prompt for contact name and insert a link to contact."
  (interactive)
  (let ((name (rrogg/prompt-contact-name)))
    (insert (concat "[[id:" (rrogg/get-contact-property "ID" name) "][" name "]]"))))
#+END_SRC

**** Contact Properties

The following functions interact with the properties of a contact.

***** Insert or Display a Property of a Contact
:PROPERTIES:
:ID:       292faf67-ac3a-4b86-84c7-15ac51ec3596
:END:

Getting property values of contacts in =org-contacts-db= can be achieved with
=rrogg/insert-contact-property= and =rrogg/display-contact-property=, depending
on whether to insert the value in buffer or displaying the value in the
minibuffer.

#+BEGIN_SRC emacs-lisp
(defun rrogg/insert-contact-property ()
  "Prompt for contact name and a property key and insert property value."
  (interactive)
  (let* ((name (rrogg/prompt-contact-name))
         (alist (rrogg/get-contact-property-alist name t))
         (prop (rrogg/prompt-contact-property alist)))
    (insert (cdr (assoc prop alist)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun rrogg/display-contact-property ()
  "Prompt for contact name and a property key and display property value in minibuffer."
  (interactive)
  (let* ((name (rrogg/prompt-contact-name))
         (alist (rrogg/get-contact-property-alist name t))
         (prop (rrogg/prompt-contact-property alist)))
    (message "%s" (cdr (assoc prop alist)))))
#+END_SRC

***** Update a Property of a Contact
:PROPERTIES:
:ID:       5ab43656-f41d-4633-b316-39eb70afaf45
:END:

Properties of contacts can be updated from any Emacs buffer by calling
=rrogg/update-contact-property=. The function will prompt for a contact and a
property to update. If a text was selected when the function has been called,
the selected region can be used as value for the property. Else another prompt
for the value will be spawned.

#+BEGIN_SRC emacs-lisp
(defun rrogg/update-contact-property ()
  "Prompt for contact name and a property key and update its value to the selected region in current buffer or prompt for a value."
  (interactive)
  (let* ((name (rrogg/prompt-contact-name))
         (marker (cadr (assoc name (org-contacts-db))))
         (alist (rrogg/get-contact-property-alist name))
         (prop (rrogg/prompt-contact-property alist))
         (current (org-entry-get marker prop))
         (valuelist (org-with-point-at marker (org-property-values prop)))
         (value-from-region (when (use-region-p)
                              (buffer-substring-no-properties (region-beginning) (region-end))))
         (prompt (if (use-region-p)
                     (concat "Update :" prop ": (currently \"" current "\") with \"" value-from-region "\"? ")
                   (concat "Value for :" prop ": (currently \"" current "\"): ")))
         (value (if (use-region-p)
                    (if (y-or-n-p prompt)
                        value-from-region
                      current)
                  (completing-read prompt valuelist))))
    (if (not (equal value current))
             (org-entry-put marker prop value))))
#+END_SRC

**** Helper Functions for Contacts

=org-contacts-db= returns the complete list of contacts in the
=org-contacts-file= including their properties.
The list gets reduced to the sublist for the contact and further for the value
of the property passed to the function.
The reduction is based on this [[https://emacs.stackexchange.com/questions/34437/how-to-get-the-value-of-id-property-of-a-org-contacts-entry-in-an-org-capture][hint]].

#+BEGIN_SRC emacs-lisp
(defun rrogg/get-contact-property (property contact)
  "Return the value of a CONTACT's PROPERTY."
  (cdr
   (assoc property (rrogg/get-contact-property-alist contact))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun rrogg/get-contact-property-alist (contact &optional filter)
  "Return the property alist of a CONTACT.
If FILTER is non-nil, return an alist without properties that have empty values."
  (let ((alist
         (nth 1 (cdr
                 (assoc contact (org-contacts-db))))))
    (if filter
        (map-remove
         'rrogg/empty-string-cons-cell-p
         alist)
      alist)))
#+END_SRC

=rrogg/empty-string-cons-cell-p= is a predicate function that is used to decide
if a cons cell (=(key . val)=) should be removed from an alist. It will return
=t= if either key or val of the cons cell is an empty string (=""=).

#+BEGIN_SRC emacs-lisp
(defun rrogg/empty-string-cons-cell-p (key val)
  "Check if KEY or VAL contain an empty string."
  (if (or (equal key "")
          (equal val ""))
      t
    nil))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun rrogg/prompt-contact-name ()
  "Prompt for a contact name in contacts.org."
  (org-contacts-completing-read "Contact Name: "))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun rrogg/prompt-contact-property (alist &optional prompt)
  "Prompt for a property key in ALIST"
  (completing-read
   (if prompt
       prompt
     "Property: ")
   alist nil t))
#+END_SRC

*** Additional Anniversaries

To add support for other anniversaries like wedding days, date of death or other
special dates belonging to a contact or group while displaying those dates in a
individual category on the agenda, some of the code in =org-contacts.el= has to
be copied and slightly modified.

Those dates can be included into the agenda by adding the following to an org
agenda file:

#+BEGIN_EXAMPLE
%%(rrogg/org-contacts-wedding-anniversaries)
#+END_EXAMPLE

This way org-contacts also supports:

**** Church Wedding Dates

#+BEGIN_SRC emacs-lisp
(defun rrogg/org-contacts-wedding-anniversaries (&optional field format)
  "Compute FIELD wedding-anniversary for each contact, returning FORMAT.
Default FIELD value is \"WEDDINGDAY\".

Format is a string matching the following format specification:

  %h - Heading name
  %l - Link to the heading
  %y - Number of year
  %Y - Number of year (ordinal)"
  (let ((calendar-date-style 'american)
        (entry ""))
    (unless format (setq format rrogg/org-contacts-weddingday-format))
    (cl-loop for contact in (org-contacts-filter)
	         for anniv = (let ((anniv (cdr (assoc-string
					                        (or field rrogg/org-contacts-weddingday-property)
					                        (nth 2 contact)))))
			               (when anniv
			                 (calendar-gregorian-from-absolute
			                  (org-time-string-to-absolute anniv))))
	         ;; Use `diary-anniversary' to compute anniversary.
	         if (and anniv (apply 'diary-anniversary anniv))
	         collect (format-spec format
				                  `((?l . ,(org-with-point-at (cadr contact) (org-store-link nil)))
				                    (?h . ,(car contact))
				                    (?y . ,(- (calendar-extract-year date)
					                          (calendar-extract-year anniv)))
				                    (?Y . ,(let ((years (- (calendar-extract-year date)
							                               (calendar-extract-year anniv))))
					                         (format "%d%s" years (diary-ordinal-suffix years)))))))))

(defcustom rrogg/org-contacts-weddingday-property "WEDDINGDAY"
  "Name of the property for contact weddingday date."
  :type 'string
  :group 'org-contacts)

(defcustom rrogg/org-contacts-weddingday-format "Wedding Anniv.: %l (%Y)"
  "Format of the anniversary agenda entry.
The following replacements are available:

  %h - Heading name
  %l - Link to the heading
  %y - Number of year
  %Y - Number of year (ordinal)"
  :type 'string
  :group 'org-contacts)
#+END_SRC

**** Civil Wedding Dates

#+BEGIN_SRC emacs-lisp
(defun rrogg/org-contacts-civil-wedding-anniversaries (&optional field format)
  "Compute FIELD civil-wedding-anniversary for each contact, returning FORMAT.
Default FIELD value is \"CIVILWEDDINGDAY\".

Format is a string matching the following format specification:

  %h - Heading name
  %l - Link to the heading
  %y - Number of year
  %Y - Number of year (ordinal)"
  (let ((calendar-date-style 'american)
        (entry ""))
    (unless format (setq format rrogg/org-contacts-civil-weddingday-format))
    (cl-loop for contact in (org-contacts-filter)
	         for anniv = (let ((anniv (cdr (assoc-string
					                        (or field rrogg/org-contacts-civil-weddingday-property)
					                        (nth 2 contact)))))
			               (when anniv
			                 (calendar-gregorian-from-absolute
			                  (org-time-string-to-absolute anniv))))
	         ;; Use `diary-anniversary' to compute anniversary.
	         if (and anniv (apply 'diary-anniversary anniv))
	         collect (format-spec format
				                  `((?l . ,(org-with-point-at (cadr contact) (org-store-link nil)))
				                    (?h . ,(car contact))
				                    (?y . ,(- (calendar-extract-year date)
					                          (calendar-extract-year anniv)))
				                    (?Y . ,(let ((years (- (calendar-extract-year date)
							                               (calendar-extract-year anniv))))
					                         (format "%d%s" years (diary-ordinal-suffix years)))))))))

(defcustom rrogg/org-contacts-civil-weddingday-property "CIVILWEDDINGDAY"
  "Name of the property for contact civil weddingday date."
  :type 'string
  :group 'org-contacts)

(defcustom rrogg/org-contacts-civil-weddingday-format "Civil Wedding Anniv.: %l (%Y)"
  "Format of the anniversary agenda entry.
The following replacements are available:

  %h - Heading name
  %l - Link to the heading
  %y - Number of year
  %Y - Number of year (ordinal)"
  :type 'string
  :group 'org-contacts)
#+END_SRC

**** Date Since When Contact is Known

#+BEGIN_SRC emacs-lisp
(defun rrogg/org-contacts-first-met-anniversaries (&optional field format)
  "Compute FIELD first-met-anniversary for each contact, returning FORMAT.
Default FIELD value is \"FIRSTMET\".

Format is a string matching the following format specification:

  %h - Heading name
  %l - Link to the heading
  %y - Number of year
  %Y - Number of year (ordinal)"
  (let ((calendar-date-style 'american)
        (entry ""))
    (unless format (setq format rrogg/org-contacts-first-met-format))
    (cl-loop for contact in (org-contacts-filter)
	         for anniv = (let ((anniv (cdr (assoc-string
					                        (or field rrogg/org-contacts-first-met-property)
					                        (nth 2 contact)))))
			               (when anniv
			                 (calendar-gregorian-from-absolute
			                  (org-time-string-to-absolute anniv))))
	         ;; Use `diary-anniversary' to compute anniversary.
	         if (and anniv (apply 'diary-anniversary anniv))
	         collect (format-spec format
				                  `((?l . ,(org-with-point-at (cadr contact) (org-store-link nil)))
				                    (?h . ,(car contact))
				                    (?y . ,(- (calendar-extract-year date)
					                          (calendar-extract-year anniv)))
				                    (?Y . ,(let ((years (- (calendar-extract-year date)
							                               (calendar-extract-year anniv))))
					                         (format "%d%s" years (diary-ordinal-suffix years)))))))))

(defcustom rrogg/org-contacts-first-met-property "FIRSTMET"
  "Name of the property for contact firstmet date."
  :type 'string
  :group 'org-contacts)

(defcustom rrogg/org-contacts-first-met-format "First Met Anniv.: %l (%Y)"
  "Format of the anniversary agenda entry.
The following replacements are available:

  %h - Heading name
  %l - Link to the heading
  %y - Number of year
  %Y - Number of year (ordinal)"
  :type 'string
  :group 'org-contacts)
#+END_SRC

**** Date the Relationship With That Contact Started

#+BEGIN_SRC emacs-lisp
(defun rrogg/org-contacts-relationshipday-anniversaries (&optional field format)
  "Compute FIELD relationshipday-anniversary for each contact, returning FORMAT.
Default FIELD value is \"RELATIONSHIPDAY\".

Format is a string matching the following format specification:

  %h - Heading name
  %l - Link to the heading
  %y - Number of year
  %Y - Number of year (ordinal)"
  (let ((calendar-date-style 'american)
        (entry ""))
    (unless format (setq format rrogg/org-contacts-relationshipday-format))
    (cl-loop for contact in (org-contacts-filter)
	         for anniv = (let ((anniv (cdr (assoc-string
					                        (or field rrogg/org-contacts-relationshipday-property)
					                        (nth 2 contact)))))
			               (when anniv
			                 (calendar-gregorian-from-absolute
			                  (org-time-string-to-absolute anniv))))
	         ;; Use `diary-anniversary' to compute anniversary.
	         if (and anniv (apply 'diary-anniversary anniv))
	         collect (format-spec format
				                  `((?l . ,(org-with-point-at (cadr contact) (org-store-link nil)))
				                    (?h . ,(car contact))
				                    (?y . ,(- (calendar-extract-year date)
					                          (calendar-extract-year anniv)))
				                    (?Y . ,(let ((years (- (calendar-extract-year date)
							                               (calendar-extract-year anniv))))
					                         (format "%d%s" years (diary-ordinal-suffix years)))))))))

(defcustom rrogg/org-contacts-relationshipday-property "RELATIONSHIPDAY"
  "Name of the property for contact realtionshipday date."
  :type 'string
  :group 'org-contacts)

(defcustom rrogg/org-contacts-relationshipday-format "Realationship Anniv.: %l (%Y)"
  "Format of the anniversary agenda entry.
The following replacements are available:

  %h - Heading name
  %l - Link to the heading
  %y - Number of year
  %Y - Number of year (ordinal)"
  :type 'string
  :group 'org-contacts)
#+END_SRC

**** Date of Proposal

#+BEGIN_SRC emacs-lisp
(defun rrogg/org-contacts-proposalday-anniversaries (&optional field format)
  "Compute FIELD proposalday-anniversary for each contact, returning FORMAT.
Default FIELD value is \"PROPOSALDAY\".

Format is a string matching the following format specification:

  %h - Heading name
  %l - Link to the heading
  %y - Number of year
  %Y - Number of year (ordinal)"
  (let ((calendar-date-style 'american)
        (entry ""))
    (unless format (setq format rrogg/org-contacts-proposalday-format))
    (cl-loop for contact in (org-contacts-filter)
	         for anniv = (let ((anniv (cdr (assoc-string
					                        (or field rrogg/org-contacts-proposalday-property)
					                        (nth 2 contact)))))
			               (when anniv
			                 (calendar-gregorian-from-absolute
			                  (org-time-string-to-absolute anniv))))
	         ;; Use `diary-anniversary' to compute anniversary.
	         if (and anniv (apply 'diary-anniversary anniv))
	         collect (format-spec format
				                  `((?l . ,(org-with-point-at (cadr contact) (org-store-link nil)))
				                    (?h . ,(car contact))
				                    (?y . ,(- (calendar-extract-year date)
					                          (calendar-extract-year anniv)))
				                    (?Y . ,(let ((years (- (calendar-extract-year date)
							                               (calendar-extract-year anniv))))
					                         (format "%d%s" years (diary-ordinal-suffix years)))))))))

(defcustom rrogg/org-contacts-proposalday-property "PROPOSALDAY"
  "Name of the property for contact proposalday date."
  :type 'string
  :group 'org-contacts)

(defcustom rrogg/org-contacts-proposalday-format "Proposal Anniv.: %l (%Y)"
  "Format of the anniversary agenda entry.
The following replacements are available:

  %h - Heading name
  %l - Link to the heading
  %y - Number of year
  %Y - Number of year (ordinal)"
  :type 'string
  :group 'org-contacts)
#+END_SRC

**** Date the Contact Passed Away

#+BEGIN_SRC emacs-lisp
(defun rrogg/org-contacts-dayofdeath-anniversaries (&optional field format)
  "Compute FIELD dayofdeath-anniversary for each contact, returning FORMAT.
Default FIELD value is \"DAYOFDEATH\".

Format is a string matching the following format specification:

  %h - Heading name
  %l - Link to the heading
  %y - Number of year
  %Y - Number of year (ordinal)"
  (let ((calendar-date-style 'american)
        (entry ""))
    (unless format (setq format rrogg/org-contacts-dayofdeath-format))
    (cl-loop for contact in (org-contacts-filter)
	         for anniv = (let ((anniv (cdr (assoc-string
					                        (or field rrogg/org-contacts-dayofdeath-property)
					                        (nth 2 contact)))))
			               (when anniv
			                 (calendar-gregorian-from-absolute
			                  (org-time-string-to-absolute anniv))))
	         ;; Use `diary-anniversary' to compute anniversary.
	         if (and anniv (apply 'diary-anniversary anniv))
	         collect (format-spec format
				                  `((?l . ,(org-with-point-at (cadr contact) (org-store-link nil)))
				                    (?h . ,(car contact))
				                    (?y . ,(- (calendar-extract-year date)
					                          (calendar-extract-year anniv)))
				                    (?Y . ,(let ((years (- (calendar-extract-year date)
							                               (calendar-extract-year anniv))))
					                         (format "%d%s" years (diary-ordinal-suffix years)))))))))

(defcustom rrogg/org-contacts-dayofdeath-property "DAYOFDEATH"
  "Name of the property for contact day of death date."
  :type 'string
  :group 'org-contacts)

(defcustom rrogg/org-contacts-dayofdeath-format "Anniv. of Death: %l (%Y)"
  "Format of the anniversary agenda entry.
The following replacements are available:

  %h - Heading name
  %l - Link to the heading
  %y - Number of year
  %Y - Number of year (ordinal)"
  :type 'string
  :group 'org-contacts)
#+END_SRC

** Agenda

The agenda is the central dashboard showing an overview of tasks. That my be all
my work related tasks for a day, my meeting appointments for the next week or
the tasks belonging to a private project. Invoking =C-c a= anywhere in Emacs
will show the main menu of the agenda feature of Org mode.

All org files specified in the variable =org-agenda-files= contribute to the
agenda.

#+BEGIN_SRC emacs-lisp
(use-package org
  :config
  (setq org-agenda-files '("~/org/refile.org" "~/org/agenda-settings.org" "~/org/work/work.org" "~/org/private/private.org" "~/org/family/family.org"))
  :bind ("C-c a" . org-agenda))
#+END_SRC

*** Agenda Views

How the agenda is rendered is of course customizable.
Agenda views can be saved to the =org-agenda-custom-commands= list and will be
presented as an option when calling the agenda dispatcher with =C-c a=.

The agenda setup is drawing heavily from the amazing work of [[http://doc.norang.ca/org-mode.html][Bernt Hansen]].

#+BEGIN_SRC emacs-lisp :noweb yes
(use-package org
  :config
  (setq org-agenda-custom-commands '())
  (add-to-list 'org-agenda-custom-commands
          <<my-agenda>>)
  (add-to-list 'org-agenda-custom-commands
          <<my-work-agenda>>)
  (add-to-list 'org-agenda-custom-commands
          <<my-private-agenda>>))
#+END_SRC

**** My Agenda

The main agenda is a composition of multiple agenda commands. The list syntax
for a composite agenda buffer is
=(key desc (cmd1 cmd2 ...) general-settings-for-whole-set files)=.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref my-agenda
'(<<my-agenda-key-desc>>
  (<<my-agenda-cmd-agenda>>
   <<my-agenda-cmd-refile>>
   <<my-agenda-cmd-stuck-project>>
   <<my-agenda-cmd-project>>
   <<my-agenda-cmd-project-next>>
   <<my-agenda-cmd-standalone>>
   <<my-agenda-cmd-project-plan>>
   <<my-agenda-cmd-waiting>>))
#+END_SRC

The agenda can be called by pressing =key= when on the agenda dispatcher. The
complete key command is =C-c a SPC=.
A description of the view is passed to the agenda dispatcher via =desc=.

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref my-agenda-key-desc
" " "My Agenda"
#+END_SRC

***** Daily/Weekly Agenda

The daily/weekly agenda is at the top of the buffer.
It is spawned by a non-matching agenda command with syntax =(cmd "" settings)=.

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref my-agenda-cmd-agenda
(agenda "")
#+END_SRC

***** Headings to Refile

Headings that have been captured but still need to be refiled, appear below the
daily/weekly agenda.
There is an agenda command =tags= that matches tags/properties/todos in all
agenda files. General syntax for matching agenda commands is =(cmd "match"
settings files)=.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref my-agenda-cmd-refile
(<<my-agenda-cmd-refile-cmd-match>>
      <<my-agenda-cmd-refile-settings>>)
#+END_SRC

All of the headings to be shown here have a tag =:REFILE:= assigned to them, so
it will search for this tag.

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref my-agenda-cmd-refile-cmd-match
tags "REFILE"
#+END_SRC

The way the matching headings are presented can be adjusted using settings.
The header of the refile section is changed.
Subtrees of a match are skipped in order to prevent a potentially very long list
of matches.

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref my-agenda-cmd-refile-settings
((org-agenda-overriding-header "Headings to Refile")
 (org-tags-match-list-sublevels nil))
#+END_SRC

***** Stuck Projects
:PROPERTIES:
:ID:       ca4c4ff1-0d86-460d-bd68-ec5f96d549b3
:END:

A stuck project is one that does not have any subtask (or subproject) that can
be worked on right now. To unstuck a project, at least one of its tasks has to
be in a =NEXT= state.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref my-agenda-cmd-stuck-project
(<<my-agenda-cmd-stuck-project-cmd-match>>
      <<my-agenda-cmd-stuck-project-settings>>)
#+END_SRC

Exclude projects that are on hold or cancelled.

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref my-agenda-cmd-stuck-project-cmd-match
tags-todo "/!-HOLD-CANCELLED-PLANNING"
#+END_SRC

Projects can't be found with todo-states alone, because I don't have a dedicated
state for them.
Therefore the function [[id:8dc94898-0f38-4aee-b1be-db569f3879a3][=rrogg/skip-non-stuck-projects=]] is called, which decides
which headings to skip for being displayed in this section on the agenda.

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref my-agenda-cmd-stuck-project-settings
((org-agenda-overriding-header "Stuck Projects")
 (org-agenda-skip-function 'rrogg/skip-non-stuck-projects))
#+END_SRC

***** Projects

Projects that can be worked on are listed in this section. Those projects have
at least one task in =NEXT= state, that is unblocked and can be worked on.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref my-agenda-cmd-project
(<<my-agenda-cmd-project-cmd-match>>
      <<my-agenda-cmd-project-settings>>)
#+END_SRC

Cancelled and on-hold projects are not displayed.
Also projects still in planning phase are excluded.

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref my-agenda-cmd-project-cmd-match
tags-todo "/!-HOLD-CANCELLED-PLANNING"
#+END_SRC

The skip function that identifies projects is [[id:6faa31dc-43a0-447a-88d0-fffbe14a3cb0][=rrogg/skip-non-projects=]].

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref my-agenda-cmd-project-settings
((org-agenda-overriding-header "Projects")
 (org-agenda-skip-function 'rrogg/skip-non-projects)
 (org-tags-match-list-sublevels 'indented))
#+END_SRC

***** Project Next Tasks

Tasks in =NEXT= state, that move a project towards its goal, are listed in this
section. If a task is displayed here, it can be worked on right away.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref my-agenda-cmd-project-next
(<<my-agenda-cmd-project-next-cmd-match>>
      <<my-agenda-cmd-project-next-settings>>)
#+END_SRC

Given by the section name, only =NEXT= stated are valid.

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref my-agenda-cmd-project-next-cmd-match
tags-todo "/!-HOLD-CANCELLED-WAITING-CALL"
#+END_SRC

[[id:b5c5c889-06c7-46b2-a89d-32327610f5a9][Standalone tasks]] are excluded from this section. Those are tasks that are
independent from a project and have their own section.
The skip function is [[id:61741020-afa3-43ed-8db2-ba936490c0cd][=rrogg/skip-projects-standalone=]].

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref my-agenda-cmd-project-next-settings
((org-agenda-overriding-header "Project Next Tasks")
 (org-agenda-skip-function 'rrogg/skip-projects-standalone))
#+END_SRC

***** Standalone Tasks
:PROPERTIES:
:ID:       b5c5c889-06c7-46b2-a89d-32327610f5a9
:END:

Independent tasks, meaning tasks that are not contributing towards a common goal
within a project, are displayed separately.
All headings under this section must have a todo-state. Therefore the agenda
command =tags-todo= is fitting, because it automatically skips non-task
headings.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref my-agenda-cmd-standalone
(<<my-agenda-cmd-standalone-cmd-match>>
      <<my-agenda-cmd-standalone-settings>>)
#+END_SRC

All tasks are matched against the following todo-states or tags:
- Skip tasks tagged =:REFILE:= - those are gathered in section =Headings to
  Refile=.
- Skip =CANCELLED= tasks - those are gathered elsewhere.
- Skip =CALL= tasks - those are only shown in the agenda.

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref my-agenda-cmd-standalone-cmd-match
tags-todo "-REFILE/!-CANCELLED-CALL-WAITING"
#+END_SRC

The remaining candidates to display still contain projects and project tasks.
Those need to be skipped. A function can be assigned to
=org-agenda-skip-function= in order to do this step.
The skip function should return =nil= in case the current match should not be
skipped. In case the match should be skipped, the return value must be a
position from which the search for the next match should be continued.

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref my-agenda-cmd-standalone-settings
((org-agenda-overriding-header "Standalone Tasks")
 (org-agenda-skip-function 'rrogg/skip-project-tasks))
#+END_SRC

***** Planned Projects
:PROPERTIES:
:ID:       a23e5e51-6634-4807-a5db-5d772c8ea1b3
:END:

Projects that are not completely planned and need some more thought before they
can be started have their own section. I can't work on tasks for those projects
right now. But still, I want to have them visible in order to drive me to
complete the planning.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref my-agenda-cmd-project-plan
(<<my-agenda-cmd-project-plan-cmd-match>>
      <<my-agenda-cmd-project-plan-settings>>)
#+END_SRC

All projects to be considered in this section are in =PLANNING= state.

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref my-agenda-cmd-project-plan-cmd-match
tags-todo "/!-HOLD-CANCELLED+PLANNING"
#+END_SRC

The skip function is the same as for regular projects
([[id:6faa31dc-43a0-447a-88d0-fffbe14a3cb0][=rrogg/skip-non-projects=]]).

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref my-agenda-cmd-project-plan-settings
((org-agenda-overriding-header "Planned Projects")
 (org-agenda-skip-function 'rrogg/skip-non-projects))
#+END_SRC

***** Waiting and On-Hold Tasks

All tasks that I am waiting on or that I put on hold for now, are listed
here. This sections prevents that those tasks are forgotten and acts as a
reminder to reinvestigate why they are blocked.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref my-agenda-cmd-waiting
(<<my-agenda-cmd-waiting-cmd-match>>
      <<my-agenda-cmd-waiting-settings>>)
#+END_SRC

=WAITING= and =HOLD= states are considered to be shown here.

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref my-agenda-cmd-waiting-cmd-match
tags-todo "/!-CANCELLED+WAITING|+HOLD"
#+END_SRC

Everything that is not a task will be skipped by [[id:25074132-89d0-4e89-98bd-be8e34637b75][=rrogg/skip-non-tasks=]].

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref my-agenda-cmd-waiting-settings
((org-agenda-overriding-header "Waiting and On-Hold Tasks")
 (org-agenda-skip-function 'rrogg/skip-non-tasks))
#+END_SRC

**** My Work Agenda

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref my-work-agenda
'(<<my-work-agenda-key-desc>>
  (<<my-agenda-cmd-agenda>>
   <<my-agenda-cmd-refile>>
   <<my-agenda-cmd-stuck-project>>
   <<my-agenda-cmd-project>>
   <<my-agenda-cmd-project-next>>
   <<my-agenda-cmd-standalone>>
   <<my-agenda-cmd-project-plan>>
   <<my-agenda-cmd-waiting>>)
  ((org-agenda-files '("~/org/refile.org" "~/org/agenda-settings.org" "~/org/work/work.org" "~/org/family/family.org"))))
#+END_SRC

The agenda can be called by pressing =key= when on the agenda dispatcher. The
complete key command is =C-c a w=.
A description of the view is passed to the agenda dispatcher via =desc=.

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref my-work-agenda-key-desc
"w" "My Work Agenda"
#+END_SRC

**** My Private Agenda

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref my-private-agenda
'(<<my-private-agenda-key-desc>>
  (<<my-agenda-cmd-agenda>>
   <<my-agenda-cmd-refile>>
   <<my-agenda-cmd-stuck-project>>
   <<my-agenda-cmd-project>>
   <<my-agenda-cmd-project-next>>
   <<my-agenda-cmd-standalone>>
   <<my-agenda-cmd-project-plan>>
   <<my-agenda-cmd-waiting>>)
  ((org-agenda-files '("~/org/refile.org" "~/org/agenda-settings.org" "~/org/private/private.org" "~/org/family/family.org"))))
#+END_SRC

The agenda can be called by pressing =key= when on the agenda dispatcher. The
complete key command is =C-c a p=.
A description of the view is passed to the agenda dispatcher via =desc=.

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref my-private-agenda-key-desc
"p" "My Private Agenda"
#+END_SRC

**** Functions for Agenda Building

***** Skip Functions

These functions are used for skipping headings that have been matched during
creating of the agenda.
The expected return values are:
- =position=: In case of identification of a heading that should be skipped, the
  position from where to continue is the return value.
- =nil=: In case of a heading that should not be skipped.

****** Skip Projects and Project Tasks
:PROPERTIES:
:ID:       4743e8ba-4c6c-459b-9c26-a669ad843dc8
:END:

First of, =save-restriction= saves the current buffer’s restrictions when it is
entered and restores them when it is exited.
Then potential narrowing of the buffer gets removed with =widen=.
A local binding for the variable =end-of-subtree= is created using =let=. This
binding will only be in effect within the body of the =let= statement.
The variable =end-of-subtree= holds the position of the end of the subtree
visited by =org-end-of-subtree=. This is possible to do so because it is
encapsulated in a =save-excursion= special form. This saves point and current
buffer, executes =org-end-of-subtree= and restores the previous state of point
and buffer.
The body of =let= is a conditional control structure =cond=. The body of the
first condition successfully is returned. If non succeeds the return value is
=nil=.
The headings will be checked against [[id:4564159d-6e4b-43a2-9ec5-7650d25501c7][=rrogg/is-project-p=]]. If this functions
returns =t=, the complete subtree will be skipped.

#+BEGIN_SRC emacs-lisp
(defun rrogg/skip-project-tasks ()
  "Skip org-headings that are part of a project.
If heading should be skipped, return position of end of subtree to continue searching.
Return nil in case the heading should not be skipped."
  (save-restriction
    (widen)
    (let ((end-of-subtree (save-excursion (org-end-of-subtree t))))
      (cond
       ((rrogg/is-project-p)
        end-of-subtree)
       (t
        nil)))))
#+END_SRC

****** Skip Non-Projects
:PROPERTIES:
:ID:       6faa31dc-43a0-447a-88d0-fffbe14a3cb0
:END:

This function follows the same structure as [[id:4743e8ba-4c6c-459b-9c26-a669ad843dc8][=rrogg/skip-project-tasks=]].
Headings will be checked against [[id:10e7b990-3bb5-4a81-8015-d0b7c59fa95c][=rrogg/is-stuck-project-p=]] and
[[id:4564159d-6e4b-43a2-9ec5-7650d25501c7][=rrogg/is-project-p=]].

#+BEGIN_SRC emacs-lisp
(defun rrogg/skip-non-projects ()
  "Skip org-headings that are not projects.
If heading should be skipped, return position of end of subtree to continue searching.
Return nil in case the heading should not be skipped."
  (save-restriction
    (widen)
    (let ((end-of-subtree (save-excursion (org-end-of-subtree t))))
      (cond
       ((rrogg/is-stuck-project-p)
        end-of-subtree)
       ((rrogg/is-project-p)
        nil)
       (t
        end-of-subtree)))))
#+END_SRC

****** Skip Non-Project Tasks
:PROPERTIES:
:ID:       65df0c1d-cc31-4823-9153-a0362b0257f9
:END:

Similar structure to the previous skip functions.

#+BEGIN_SRC emacs-lisp
(defun rrogg/skip-non-project-tasks ()
  "Skip org-headings that are projects, subproject tasks or standalone tasks.
If heading should be skipped, return position of end of subtree to continue searching.
Return nil in case the heading should not be skipped."
  (save-restriction
    (widen)
    (let ((end-of-subtree (save-excursion (org-end-of-subtree t)))
          (next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((rrogg/is-project-p)
        next-headline)
       ((and (rrogg/is-project-task-p)
             (equal (org-get-todo-state) "NEXT"))
        end-of-subtree)
       ((not (rrogg/is-project-task-p))
        end-of-subtree)
       (t
        nil)))))
#+END_SRC

****** Skip Projects and Standalone Tasks
:PROPERTIES:
:ID:       61741020-afa3-43ed-8db2-ba936490c0cd
:END:

Similar structure to the previous skip functions.

#+BEGIN_SRC emacs-lisp
(defun rrogg/skip-projects-standalone ()
  "Skip org-headings that are projects or standalone tasks.
If heading should be skipped, return position of end of subtree to continue searching.
Return nil in case the heading should not be skipped."
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((rrogg/is-project-p)
        next-headline)
       ((and (rrogg/is-task-p) (not (rrogg/is-project-task-p)))
        next-headline)
       ((rrogg/is-project-planning-task-p)
        next-headline)
       (t
        nil)))))
#+END_SRC

****** Skip Non-Stuck-Projects
:PROPERTIES:
:ID:       8dc94898-0f38-4aee-b1be-db569f3879a3
:END:

Similar structure to the previous skip functions.

#+BEGIN_SRC emacs-lisp
(defun rrogg/skip-non-stuck-projects ()
  "Skip org-headings that are projects and not stuck.
If heading should be skipped, return position of end of subtree to continue searching.
Return nil in case the heading should not be skipped."
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((rrogg/is-project-planning-task-p)
        next-headline)
       ((rrogg/is-project-hold-task-p)
        next-headline)
       ((rrogg/is-stuck-project-p)
        nil)
       (t
        next-headline)))))
#+END_SRC

****** Skip Non-Tasks
:PROPERTIES:
:ID:       25074132-89d0-4e89-98bd-be8e34637b75
:END:

Similar structure to the previous skip functions.

#+BEGIN_SRC emacs-lisp
(defun rrogg/skip-non-tasks ()
  "Skip org-headings that are projects or subprojects.
If heading should be skipped, return position of end of subtree to continue searching.
Return nil in case the heading should not be skipped."
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((rrogg/is-task-p)
        nil)
       (t
        next-headline)))))
#+END_SRC

***** Identification Functions

The following functions are used to identify what kind of org-heading or task an
entry is.
Return value is either =t= or =nil=.

****** Identify Projects
:PROPERTIES:
:ID:       4564159d-6e4b-43a2-9ec5-7650d25501c7
:END:

Current buffer's restrictions are saved via =save-restriction= and restored when
the function is exited.
Then potential narrowing of the buffer gets removed with =widen=.
Three local bindings for variables are needed in order to determine if the tasks
is a project:
- =end-of-subtree=: Holds the position of the end of the subtree visited by
  =org-end-of-subtree=.
- =is-task=: Checks if org-heading has a todo keyword, returns boolean.
- =has-subtask=: Boolean, default value is =nil=.
Because this function examines the org-headings coming after the current one,
point is moved one line forward.
The following =while= control loop searches for the next org-heading and sets
the variable =has-subtask= to =t= if the org-heading contains a todo keyword.
The return value is =t= if both of =is-task= and =has-subtask= are =t=.

#+BEGIN_SRC emacs-lisp
(defun rrogg/is-project-p ()
  "A task with a subtask is a project."
  (save-restriction
    (widen)
    (let ((end-of-subtree (save-excursion (org-end-of-subtree t)))
          (is-task (member (org-get-todo-state) org-todo-keywords-1))
          (has-subtask))
      (save-excursion
        (forward-line 1)
        (while (and (< (point) end-of-subtree)
                    (re-search-forward "^\*+ " end-of-subtree t)
                    (not has-subtask))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      (and is-task has-subtask))))
#+END_SRC

****** Identify Stuck Projects
:PROPERTIES:
:ID:       10e7b990-3bb5-4a81-8015-d0b7c59fa95c
:END:

Similar structure to the previous identify function.

#+BEGIN_SRC emacs-lisp
(defun rrogg/is-stuck-project-p ()
  "A task without a subtask in NEXT state is a stuck project."
  (save-restriction
    (widen)
    (if (rrogg/is-project-p)
        (let ((end-of-subtree (save-excursion (org-end-of-subtree t)))
              (has-next-subtask))
          (save-excursion
            (forward-line 1)
            (while (and (< (point) end-of-subtree) (re-search-forward "^\*+ NEXT\\|CALL " end-of-subtree t) (not has-next-subtask))
              (setq has-next-subtask t)))
          (if has-next-subtask
              nil
            t))
      nil)))
#+END_SRC

****** Identify Tasks
:PROPERTIES:
:ID:       4b9cc45a-ced1-4b52-804e-277fb0d97166
:END:

Similar structure to the previous identify functions.

#+BEGIN_SRC emacs-lisp
(defun rrogg/is-task-p ()
  "Check if task has no subtask."
  (save-restriction
    (widen)
    (let ((end-of-subtree (save-excursion (org-end-of-subtree t)))
          (is-task (member (org-get-todo-state) org-todo-keywords-1))
          (has-subtask))
      (save-excursion
        (forward-line 1)
        (while (and (< (point) end-of-subtree)
                    (re-search-forward "^\*+ " end-of-subtree t)
                    (not has-subtask))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      (and is-task (not has-subtask)))))
#+END_SRC

****** Identify Project Task
:PROPERTIES:
:ID:       898ba890-792b-4d57-a67e-255e88f5ef68
:END:

Similar structure to the previous identify functions.

#+BEGIN_SRC emacs-lisp
(defun rrogg/is-project-task-p ()
  "Check if task is part of a project."
  (save-restriction
    (widen)
    (let ((parent-task (save-excursion (org-back-to-heading t) (point))))
      (save-excursion
        (rrogg/find-parent-task)
        (if (equal (point) parent-task)
            nil
          t)))))
#+END_SRC

****** Identify Project Planning Task

Similar structure to the previous identify functions.

#+BEGIN_SRC emacs-lisp
(defun rrogg/is-project-planning-task-p ()
  "Check if task is part of a project in planning state."
  (save-restriction
    (widen)
    (let ((parent-task (save-excursion (org-back-to-heading t) (point))))
      (save-excursion
        (rrogg/find-parent-planning-task)
        (if (equal (point) parent-task)
            nil
          t)))))
#+END_SRC
****** Identify Project Hold Task

Similar structure to the previous identify functions.

#+BEGIN_SRC emacs-lisp
(defun rrogg/is-project-hold-task-p ()
  "Check if task is part of a project in hold state."
  (save-restriction
    (widen)
    (let ((parent-task (save-excursion (org-back-to-heading t) (point))))
      (save-excursion
        (rrogg/find-parent-hold-task)
        (if (equal (point) parent-task)
            nil
          t)))))
#+END_SRC

***** Search Functions

The following functions are used to search for specific org-headings or tasks.
Return value is the position of point at the beginning of the heading or =nil=.

****** Find Parent Task
:PROPERTIES:
:ID:       1e618736-8432-4213-84cf-94b9835a8ede
:END:

#+BEGIN_SRC emacs-lisp
(defun rrogg/find-parent-task ()
  "Move point to the parent task of a task."
  (save-restriction
    (widen)
    (let ((parent-task (save-excursion (org-back-to-heading t) (point))))
      (while (org-up-heading-safe)
        (when (member (org-get-todo-state) org-todo-keywords-1)
          (setq parent-task (point))))
      (goto-char parent-task))))
#+END_SRC

****** Find Parent Planning Task

#+BEGIN_SRC emacs-lisp
(defun rrogg/find-parent-planning-task ()
  "Move point to the parent planning task of a task."
  (save-restriction
    (widen)
    (let ((parent-task (save-excursion (org-back-to-heading t) (point))))
      (while (org-up-heading-safe)
        (when (equal (org-get-todo-state) "PLANNING")
          (setq parent-task (point))))
      (goto-char parent-task))))
#+END_SRC

****** Find Parent Hold Task

#+BEGIN_SRC emacs-lisp
(defun rrogg/find-parent-hold-task ()
  "Move point to the parent hold task of a task."
  (save-restriction
    (widen)
    (let ((parent-task (save-excursion (org-back-to-heading t) (point))))
      (while (org-up-heading-safe)
        (when (equal (org-get-todo-state) "HOLD")
          (setq parent-task (point))))
      (goto-char parent-task))))
#+END_SRC

*** Show Small Icons in Agenda View

Some agenda entries belonging to a certain category have a small 16 x 16 pixel
icon assigned to them. If the entries category has no icon assigned, it is
displayed 16 pixels further right.

The icons are stored in =~/templates_labels/icons/=.

#+BEGIN_SRC emacs-lisp
(use-package org
  :config
  (setq org-agenda-category-icon-alist
        '(("\\(Holiday\\|Vacation\\)" "~/templates_labels/icons/holiday.png" nil nil :ascent center)
          ("Anniv." "~/templates_labels/icons/anniversary.png" nil nil :ascent center)
          ("Spec. Date" "~/templates_labels/icons/specialdate.png" nil nil :ascent center)
          ("Time" "~/templates_labels/icons/time.png" nil nil :ascent center)
          ("Marriage" "~/templates_labels/icons/marriage.gif" nil nil :ascent center)
          ("Love" "~/templates_labels/icons/love.png" nil nil :ascent center)
          ("Mourning" "~/templates_labels/icons/mourning.png" nil nil :ascent center)
          (".*" '(space . (:width (16)))))))
#+END_SRC

** Code Blocks
:PROPERTIES:
:ID:       50f4300a-4e3d-42f7-9807-3d59be92b575
:END:

Source blocks can be edited in a window that uses the mode for the programming
language of the block. This window will be spawned on top of the current window
leaving the window configuration intact.
The source code will be fontified and indented in the code block as expected for
the language of the code.

#+BEGIN_SRC emacs-lisp
(use-package org
  :config
  (setq org-src-window-setup 'current-window)
  (setq org-src-fontify-natively t)
  (setq org-edit-src-content-indentation 0))
#+END_SRC

** Word-processing
:PROPERTIES:
:ID:       bc8c2256-161d-40cd-9bd4-e5f64f049c2d
:END:

Utilizing LaTeX to produce perfect letters and other documents for printing and
sharing through the org mode export feature is a huge deal. Ideally all of the
LaTeX syntax for a document is hidden away in the settings and especially in lco
files. Just adding lco's via =#+LCO:= shall be enough additional code besides
the actual content of the document.
The lco's for a Linux system are located in =~/texmf/tex/latex/=.
On Windows systems, the lco's have to be placed in the folder
=C:\texlive\texmf-local\tex\latex=. Sometimes it is necessary to use the command
=mktexlsr= in =cmd.exe= when a new lco is added to this folder. I had some
problems setting this up, but [[https://orgmode.org/worg/exporters/koma-letter-export.html#org08cc3a][this section]] has been a great help.
For a clean and frictionless letter writing experience the org export template
has to be as minimal as possible.

#+BEGIN_SRC emacs-lisp
(eval-after-load 'ox '(require 'ox-koma-letter))
(eval-after-load 'ox-koma-letter
  '(progn
     (add-to-list 'org-latex-classes
                  '("rrogg/letter"
                    "\\documentclass\{scrlttr2\}
     [NO-DEFAULT-PACKAGES]
     [NO-PACKAGES]
     [NO-EXTRA]"))
     (setq org-koma-letter-default-class "rrogg/letter")))
(setq org-latex-hyperref-template "")
(setq org-koma-letter-email nil)
(setq org-koma-letter-use-foldmarks nil)
#+END_SRC

** Org Mode Config Finished

#+BEGIN_SRC emacs-lisp
(message "→★ Org mode finished in %.2fs" (float-time (time-subtract (current-time) rrogg/org-config-start-time)))
#+END_SRC

* Final Spurt

This is the end of Cortex. Let's see how much time it took to load all of the
shenanigans. Write the result to the =Messages= buffer.
List missing binaries needed for certain functionality of Cortex. 

#+BEGIN_SRC emacs-lisp
(message "→★ Finished loading Cortex in %.2fs" (float-time (time-subtract (current-time) rrogg/cortex-start-time)))
(message "»»» Binaries not found in checks above: %s\n" rrogg/binary-not-found-list)
#+END_SRC
