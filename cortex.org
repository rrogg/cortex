#+TITLE: CORTEX - AN EMACS CONFIGURATION
#+PROPERTY: header-args :result silent :tangle "~/.emacs.d/init.el" :eval no-export :comments org

* Track Loading Time of Cortex

Starting Emacs has to be as quick as possible. In order to evaluate the time it
takes to load Cortex, someone has to blow the whistle and start the stopwatch.

#+BEGIN_SRC emacs-lisp
(defvar my-cortex-start-time (current-time) "Time when Cortex was started")
#+END_SRC

The start time is also used in logs. The format of the time string is different
from =my-cortex-start-time=.

#+BEGIN_SRC emacs-lisp
(setq my-cortex-start-time-iso (format-time-string "%Y-%m-%dT%T"))
#+END_SRC

* Server Start

Emacs offers a server mode, which allows to open additional from outside of
Emacs in the same session that is already running. No need to open a file in
another Emcas and reload the complete config again for it.

#+BEGIN_SRC emacs-lisp
(server-start)
#+END_SRC

* Support for Non-Linux Systems

** Windows

*** Installation
Emacs is installed from chocolatey via =cmd.exe=:

#+BEGIN_EXAMPLE
choco install emacs
#+END_EXAMPLE

The environment variable =HOME= does not exist by default, so it needs to be
created manually:

#+BEGIN_EXAMPLE
This PC (right-click)
-> Properties
-> Computer name, domain, and workgroup settings
-> Change settings
-> Advanced
-> Environment Variables...
-> New
HOME C:\home\rrogg
#+END_EXAMPLE

On first start of Emacs, the =~/.emacs.d/= directory gets created automatically.

*** Cloning Cortex Repository

In order to clone the Cortex repository, install =git= from =chocolatey= via
=cmd.exe=:

#+BEGIN_EXAMPLE
choco install git
#+END_EXAMPLE

=git= should be automatically found by Emacs, no need to add it to the path.

Clone Cortex via =git bash=:

#+BEGIN_EXAMPLE
cd ~/src
git clone https://github.com/rrogg/cortex.git
#+END_EXAMPLE

*** Generall Issues

**** =~/.emacs.d/server/= unsafe location

Emacs complaints about =~/.emacs.d/server/= not beeing a safe loacation (magit,
server-start).
This is resolved by changing the access rights to that folder via =cmd.exe=:

#+BEGIN_EXAMPLE
cd %HOME%\.emacs.d
takeown /f server
#+END_EXAMPLE

**** Attach Files to Already Open Emacs Session

When Emacs is started as a daemon (=(server-start)=), all additionaly opened
files should be openend within the current session and not in a seperate
instance of Emacs. That instance would load Cortex again, which takes time. The
buffer list is also not shared between those instances.

Emacs on Windows comes with several execuatables, of which I use two:

- =runemacs.exe=
- =emacsclientw.exe=

Should Emacs not be started, e.g. after a reboot, I use =runemacs.exe= to do so.
Loading Cortex, Emacs will create a daemon in the background, to which other
files can be attached when they are opened.
Opening files is either done directly from within Emacs or by opening them from
a folder.
In order to always attach those externaly opened files to the running session, I
use =emacsclientw.exe= with some parameters. It needs a file name to open in order to
start Emacs, so I can't use it to start Emacs in a way that it always does what
I want.
The =Target= value of the shortcut is the following:

#+BEGIN_EXAMPLE
C:\ProgramData\chocolatey\bin\emacsclientw.exe -n -a ""
#+END_EXAMPLE

If there is a Emacs server running, it will open the file in the current
session. If no server has been started yet, it will do so (=-a ""=).

Now this shortcut has to be set as default programm to open the specific file
extension with. This has to be done once per file extension.
It could also be set via Windows Registry, but I failed to add more file
extensions to the =.reg= file. This file just needs to be executed and it will
set the default programm.

#+BEGIN_EXAMPLE
Windows Registry Editor Version 5.00
[HKEY_CURRENT_USER\Software\Classes\texfile]
[HKEY_CURRENT_USER\Software\Classes\texfile\Shell]
[HKEY_CURRENT_USER\Software\Classes\texfile\Shell\Open]
[HKEY_CURRENT_USER\Software\Classes\texfile\Shell\Open\Command]
@="C:\\ProgramData\\chocolatey\\bin\\emacsclientw.exe -n -a \"C:\\ProgramData\\chocolatey\\bin\\runemacs.exe\" \"%1\" %*"
[HKEY_CURRENT_USER\Software\Classes\.tex]
@="texfile"
[HKEY_CURRENT_USER\Software\Classes\.bib]
@="texfile"
[HKEY_CURRENT_USER\Software\Classes\.lco]
@="texfile"
[HKEY_CURRENT_USER\Software\Classes\.sty]
@="texfile"
[HKEY_CURRENT_USER\Software\Classes\.cls]
@="texfile"
[HKEY_CURRENT_USER\Software\Classes\txtfile]
[HKEY_CURRENT_USER\Software\Classes\txtfile\Shell]
[HKEY_CURRENT_USER\Software\Classes\txtfile\Shell\Open]
[HKEY_CURRENT_USER\Software\Classes\txtfile\Shell\Open\Command]
@="C:\\ProgramData\\chocolatey\\bin\\emacsclientw.exe -n -a \"C:\\ProgramData\\chocolatey\\bin\\runemacs.exe\" \"%1\" %*"
[HKEY_CURRENT_USER\Software\Classes\.txt]
@="txtfile"
[HKEY_CURRENT_USER\Software\Classes\.org]
@="txtfile"
[HKEY_CURRENT_USER\Software\Classes\scriptfile]
[HKEY_CURRENT_USER\Software\Classes\scriptfile\Shell]
[HKEY_CURRENT_USER\Software\Classes\scriptfile\Shell\Open]
[HKEY_CURRENT_USER\Software\Classes\scriptfile\Shell\Open\Command]
@="C:\\ProgramData\\chocolatey\\bin\\emacsclientw.exe -n -a \"C:\\ProgramData\\chocolatey\\bin\\runemacs.exe\" \"%1\" %*"
[HKEY_CURRENT_USER\Software\Classes\.sh]
@="scriptfile"
[HKEY_CURRENT_USER\Software\Classes\cfile]
[HKEY_CURRENT_USER\Software\Classes\cfile\Shell]
[HKEY_CURRENT_USER\Software\Classes\cfile\Shell\Open]
[HKEY_CURRENT_USER\Software\Classes\cfile\Shell\Open\Command]
@="C:\\ProgramData\\chocolatey\\bin\\emacsclientw.exe -n -a \"C:\\ProgramData\\chocolatey\\bin\\runemacs.exe\" \"%1\" %*"
[HKEY_CURRENT_USER\Software\Classes\.c]
@="cfile"
[HKEY_CURRENT_USER\Software\Classes\.h]
@="cfile"
#+END_EXAMPLE

* Disable GUI components

Display no GUI components other than the =modline=.

#+BEGIN_SRC emacs-lisp
(use-package emacs
  :init
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1))
#+END_SRC

* Wrap Lines at a Reasonable Width

Long lines of text have to be wrapped at a width of 80 characters. In order to
leave long code lines untouched, automatic line wrap is only active in
=text-mode= and modes which inherit from =text-mode=, like e.g. =org-mode=.

#+BEGIN_SRC emacs-lisp
(setq-default fill-column 80)
(add-hook 'text-mode-hook 'auto-fill-mode)
#+END_SRC

* Stop the Bell

Acoustic feedback is not wanted for this system. Therefore stop ringing the bell!

#+BEGIN_SRC emacs-lisp
(setq ring-bell-function #'ignore)
#+END_SRC

* Hide Welcome Screen and Empty =*scratch*=

Emacs shows a splash screen at startup from which one can easily get to the
tutorial. While helpful in the beginning, this screen gets abdicable with
time. Therefore it's disabled.
Emacs also automatically loads a buffer called =*scratch*=, which serves as a
place to try out emacs lisp code or to type out some ideas. This is very helpful
as one doesn't have to think about creating a new file for every unrelated
thought. The welcome message isn't needed, so it gets disabled.

#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t
      initial-scratch-message nil)
#+END_SRC

* Force a Sane Coding System

The only way to go in regards of a sane coding system for text files is utf-8.
It has to be the the default when ever possible. This provides maximal
portability and readability across operation systems and applications.
Also the Unix way of adding a new line into a text file has to be the
default. DOS uses carriage return and line feed ("\r\n") as a line ending, where
Unix uses just line feed ("\n").

#+BEGIN_SRC emacs-lisp
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8-unix)
(setq-default buffer-file-coding-system 'utf-8-unix)
(set-charset-priority 'unicode)
(setq default-process-coding-system '(utf-8-unix . utf-8-unix)
      locale-coding-system 'utf-8)
#+END_SRC

* Answer Questions Quicker

Emacs sometimes requires answering a yes-or-no question in order to make the
user aware of probably dangerous changes or decisions.
Simply pressing =y= for a positive or =n= for a negative response is way more
convenient compared to spelling out the whole words =yes= or =no=.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

* Highlight Current Line in Buffer

To make orientation within the buffer easy, the current line on which point is
gets highlighted.

#+BEGIN_SRC emacs-lisp
(global-hl-line-mode t)
#+END_SRC

* Use Ibuffer to Edit the Buffer List

By default =C-x C-b= calls the Buffer List. Ibuffer is an alternative with more
functionality when it comes to manipulate the buffer list and switching
buffers.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC

* Provide and Manage Packages
** =package.el=

Most extensions to Emacs can be loaded from archives, which are accessible via
Emacs' very own package manager =package.el=. To use this feature, =package.el=
needs to know, which archives it should use.
Out of the box, Emacs includes the =GNU ELPA= archive. It contains packages
conform with the terms of the Free Software Foundation.
For using the Org mode contribution files (some extra packages not included in
the Org mode version shipped with Emacs) and installing them via =package.el=,
the =Org ELPA= archive is added.
=MELPA= is an archive containing a lot of packages from the Open Source
community, which is the source for a lot of packages used in Cortex.
To make shure all packages mentioned in Cortex are loaded at Emacs startup, the
init file has to call the function =package-initialize=. This is necessary,
because some code blocks within Cortex depend on a packages installed by
=package.el=.

#+BEGIN_SRC emacs-lisp
(package-initialize)
(add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/") t)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
#+END_SRC

The command =M-x list-packages= brings up the package menu buffer, which lists
all packages available from the archives defined above. The command retrieves
the list of packages from the archive servers, if it has a connection to the
internet. Else it uses the most recently retrieved list.

Here are some of the frequently used commands in the package menu buffer:

| Key     | Command                      | Description                                                                                                                                                |
|---------+------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------|
| h       | (package-menu-quick-help)    | Summary of commands in the package menu buffer                                                                                                             |
| r       | (package-menu-refresh)       | Refresh package list                                                                                                                                       |
| i       | (package-menu-mark-install)  | Mark the package on the current line for installation (adds an ‘I’ character to the start of the line)                                                     |
| d       | (package-menu-mark-delete)   | Mark the package on the current line for deletion (adds a ‘D’ character to the start of the line                                                           |
| u <RET> |                              | Remove any installation or deletion mark previously added to the current line                                                                              |
| U       | (package-menu-mark-upgrades) | Mark all package with a newer available version for upgrading.  This places an ‘I’ on the new available versions, and a ‘D’ on the old installed versions. |
| x       | (package-menu-execute)       | Download and install all packages marked with ‘I’, and their dependencies; also, delete all packages marked with ‘D’                                       |

The command =(package-install PKG)= can be used to install package "PKG"
manually from a code block within Cortex.

** =use-package=

Most Emacs configurations out there tend to be quite extensive. I expect nothing
else for Cortex. Over time, it will grow and become cluttered. Loading time will
most likely go up linked to the size of packages used.
Having more control over when things get loaded or when certain code is executed
is very welcome.
The macro =use-package= provides this control. It isolates packages
configuration in an Emacs config so that code belonging to a certain package
only is executed when the package is loaded. When a package is loaded it is also
configurable. This has the potential to squeeze some performance out of Cortex
and to make Cortex clean, tidy and organized.
=use-package= obviously can't be installed by using its own macro. It needs to
be installed by the commands from =package.el=. Following the idea of using
=use-package= for every package within Cortex, this should be the only time a
package is installed without the =use-package= macro.

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
#+END_SRC

=use-package= provides several keywords to load and configure a package.
See a basic example below.

#+BEGIN_EXAMPLE emacs-lisp
(use-package foo
  :ensure t
  :init
  (setq foo-variable t)
  :config
  (foo-mode 1))
#+END_EXAMPLE

The macro starts with =use-package foo=, which will load the package =foo=, but
only, if it's already available on the system (else, a warning gets logged).

=:ensure t= makes sure, that the package is installed and will download it from
the package archives, if it's not present on the system. This is how packages
are fetched and installed in Cortex.

The =:init= keyword executes code before a package is loaded. It accepts one
or more forms, up to the next keyword. 

Similarly, =:config= can be used to execute code after a package is loaded.

* no-littering - Keep .emcas.d Clean

| [2020-10-20] | Initial setup |

#+BEGIN_SRC emacs-lisp
(use-package no-littering
  :ensure t)
(require 'no-littering)
#+END_SRC

* Logging

Because Cortex is likely used on multiple hosts, each of those requires
host-specific logging. This will make it easier to compare versions of Emacs and
its packages. The following code is heavily inspired by a [[https://github.com/novoid/dot-emacs/blob/master/config.org#host-specific-log-file-my-log-hostspecific][section in Karl Voit's
dot-emacs]].

A folder for all sorts of logs is defined in =my-cortex-var-log-directory=. If
this folder is not existing, it gets created.
The log file is defined in =my-cortex-var-log-hostname-file= and consists of the
hostname of the system.

#+BEGIN_SRC emacs-lisp
(setq my-cortex-var-log-directory (concat no-littering-var-directory "log/"))
(when (not (file-exists-p my-cortex-var-log-directory))
  (make-directory my-cortex-var-log-directory))
(setq my-cortex-var-log-hostname-file (concat my-cortex-var-log-directory "host-" system-name ".txt"))
#+END_SRC

The content of the host-specific log is similar to the following:

#+BEGIN_EXAMPLE
Started on 2020-10-20T22:09:44
emacs-version 27.1
org-version 9.1.6
magit-version 2.10.3
#+END_EXAMPLE

At startup of Emacs the host-specific log file is overwritten wit the current time.

#+BEGIN_SRC emacs-lisp
(write-region (concat "Started on " my-cortex-start-time-iso "\n") nil my-cortex-var-log-hostname-file)
#+END_SRC

Using the function =my-cortex-log-hostspecific=, will append a string,
e.g. emacs-version, and a command, e.g. =emacs-version=, to the log file.

#+BEGIN_SRC emacs-lisp
(defun my-cortex-log-hostspecific (string command)
  "append a string and the result of a command to the my-cortex-var-log-hostname-file file"
  (interactive)
  (write-region (concat string " " command "\n") nil my-cortex-var-log-hostname-file t)
)
#+END_SRC

This is the first use of the function above. Write the Emacs version to the log
file.

#+BEGIN_SRC emacs-lisp
(my-cortex-log-hostspecific "emacs-version" emacs-version)
#+END_SRC

* Check for Binaries

Some functionality in Cortex depends on external binaries.
Receiving feedback if those are present on the system is valuable for
debugging.
The function =my-binary-found= returns the path for a given binary.

#+BEGIN_SRC emacs-lisp
(defun my-binary-found(binaryname)
  "Returns the path where a binary executable can be found."
  (locate-file binaryname exec-path exec-suffixes 1))
#+END_SRC

This can be used to generate a report like below:

#+BEGIN_EXAMPLE
git binary: /usr/bin/git
aspell binary: /usr/bin/aspell
gnuplot binary:
#+END_EXAMPLE

The function =my-eval-if-binary-or-warn= checks for a given binary and writes
the binary name into the list =my-binary-not-found-list=.
The list is displayed in the =*Messages*= buffer after Cortex has been loaded.

#+BEGIN_SRC emacs-lisp
(defvar my-binary-not-found-list nil
  "Holds a list of binaries which could not be found via my-eval-if-binary-or-warn()")
(defun my-eval-if-binary-or-warn (binaryname &optional warningtext)
  "Checks if a binary can be found in the path via my-binary-found().

  If not found, a warning message is printed, which can be defined as an optional parameter as well.
  Additionally, the not found binaries are collected in the variable my-binary-not-found-list."
  (or warningtext (setq warningtext (concat "»»» I could not locate the PATH-binary for: " binaryname)))
  (let* ((binarypath (my-binary-found binaryname)))
    (if binarypath
      ;; binary was found in exec-path
      (concat binarypath)
    (progn
      ;; binary NOT found in exec-path:
      (message warningtext)
      (if my-binary-not-found-list
        (add-to-list 'my-binary-not-found-list binaryname)
        (setq my-binary-not-found-list (list binaryname)))))))
#+END_SRC

=my-eval-if-binary-or-warn= is also used to evaluate if a functionality of
Cortex should be configured or not. See the example below:

#+BEGIN_EXAMPLE
(when (my-eval-if-binary-or-warn "git")
  (use-package magit
    :ensure t))
#+END_EXAMPLE

* Redirect Backups and Auto-Saves

Emacs creates backups of every file currently opened and containing changes.
The filenames of those backups end with a tilde (=foo.bar~=). After some time
this feature messes uo folders very much. One can keep a clear view by
redirecting those backups to a central place where they can be accessed if
needed. Backups will be created for every file, even if they are version
controlled with git.
Auto-saves occurs if a file hasn’t been saved since a certain time
(=auto-save-timeout=) or a certain amount of typed characters
(=auto-save-interval=).
Files generated by auto-save have a leading and trailing ‘#’, eg. the auto-save
file for foo.bar is #foo.bar#. Auto-save files can be recovered with =M-x
recover-file <RET> file <RET>=.

#+BEGIN_SRC emacs-lisp
(setq auto-save-file-name-transforms
      `((".*" , (no-littering-expand-var-file-name "auto-save/") t))
      vc-make-backup-files t)
#+END_SRC

* Magit - Using git Within Emacs

| [2020-10-20] | Initial setup |

=magit= is a superb interface to =git=.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :if (my-eval-if-binary-or-warn "git")
  :ensure t)
#+END_SRC

** How to Write a Good Commit Message

A good commit message follows [[https://chris.beams.io/posts/git-commit/][7 rules]]:

1. Separate subject from body with a blank line
2. Limit the subject line to 50 characters
3. Capitalize the subject line
4. Do not end the subject line with a period
5. Use the imperative mood in the subject line
6. Wrap the body at 72 characters
7. Use the body to explain what and why vs. how

For example:

#+BEGIN_EXAMPLE
Summarize changes in around 50 characters or less

More detailed explanatory text, if necessary. Wrap it to about 72
characters or so. In some contexts, the first line is treated as the
subject of the commit and the rest of the text as the body. The
blank line separating the summary from the body is critical (unless
you omit the body entirely); various tools like `log`, `shortlog`
and `rebase` can get confused if you run the two together.

Explain the problem that this commit is solving. Focus on why you
are making this change as opposed to how (the code explains that).
Are there side effects or other unintuitive consequences of this
change? Here's the place to explain them.

Further paragraphs come after blank lines.

 - Bullet points are okay, too

 - Typically a hyphen or asterisk is used for the bullet, preceded
   by a single space, with blank lines in between, but conventions
   vary here

If you use an issue tracker, put references to them at the bottom,
like this:

Resolves: #123
See also: #456, #789
#+END_EXAMPLE

All stylistic rules can be taken care of by =magit=.
It will color characters on the summary line exceeding length of 50 red and does
the same for the second line, which should be blank.
The body of the message is wrapped at length 72.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :if (my-eval-if-binary-or-warn "git")
  :config
    (setq git-commit-summary-max-length 50
          git-commit-fill-column 72))
#+END_SRC

* Maximize Frame Window

The Emacs frame is maximized at all times to make use of every pixel on the
screen.

#+BEGIN_SRC emacs-lisp
(toggle-frame-maximized)
#+END_SRC

* Final Spurt

This is the end of Cortex. Let's see how much time it took to load all of the
shenanigans. Write the result to the =Messages= buffer.
List missing binaries needed for certain functionality of Cortex. 

#+BEGIN_SRC emacs-lisp
(message "→★ Finished loading Cortex in %.2fs" (float-time (time-subtract (current-time) my-cortex-start-time)))
(message "»»» Binaries not found in checks above: %s" my-binary-not-found-list)
#+END_SRC
